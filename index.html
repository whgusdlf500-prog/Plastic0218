<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>AIë·°í‹°ì‹œë®¬ë ˆì´í„° â€” ë” í‹° ë‚˜ê²Œ (Before/After ìŠ¬ë¼ì´ë”)</title>
  <meta name="description" content="ë‚´ ì‚¬ì§„ìœ¼ë¡œ ëˆˆ/ì½”/ì…/ìœ¤ê³½ ì›Œí”„ + ì»¨íˆ¬ì–´/í•˜ì´ë¼ì´íŠ¸/ì•„ì´ë¼ì¸/ë¦½/ë¸”ëŸ¬ì…” + í—¤ì–´ìŠ¤íƒ€ì¼(ì•ë¨¸ë¦¬/ë‹¨ë°œ/ì¥ë°œ) ì˜¤ë²„ë ˆì´ê¹Œì§€. Before/After ë“œë˜ê·¸ ìŠ¬ë¼ì´ë”ë¡œ í™• ì²´ê°." />
  <style>
    :root{
      --bg:#070A14;
      --line: rgba(255,255,255,.14);
      --text:#EAF0FF;
      --sub:#AAB6D6;
      --good:#35F0B5;
      --mid:#6D7CFF;
      --gold:#FFD36E;
      --shadow: 0 18px 55px rgba(0,0,0,.50);
      --r:20px;
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Apple SD Gothic Neo", "Noto Sans KR", Arial;
      color:var(--text);
      background:
        radial-gradient(1200px 720px at 18% 0%, rgba(109,124,255,.22), transparent 60%),
        radial-gradient(900px 650px at 90% 10%, rgba(53,240,181,.16), transparent 55%),
        radial-gradient(900px 650px at 55% 115%, rgba(255,211,110,.10), transparent 55%),
        linear-gradient(180deg, var(--bg), #030411 78%);
      overflow-x:hidden;
    }
    .wrap{max-width:1250px;margin:0 auto;padding:18px 16px 34px;}
    .topbar{
      display:flex; align-items:center; justify-content:space-between; gap:12px; flex-wrap:wrap;
      padding:14px 14px;
      border:1px solid var(--line);
      background: linear-gradient(180deg, rgba(255,255,255,.08), rgba(255,255,255,.03));
      border-radius: var(--r);
      box-shadow: var(--shadow);
    }
    .brand{display:flex;align-items:center;gap:12px;flex:1;min-width:280px}
    .logo{
      width:44px;height:44px;border-radius:14px;
      background: conic-gradient(from 210deg, rgba(109,124,255,.95), rgba(53,240,181,.90), rgba(255,211,110,.88), rgba(109,124,255,.95));
      box-shadow: 0 12px 30px rgba(109,124,255,.22);
      position:relative;
    }
    .logo:after{
      content:"";position:absolute;inset:9px;border-radius:12px;
      background: rgba(8,10,20,.78);
      border:1px solid rgba(255,255,255,.10);
    }
    h1{margin:0;font-size:16px;letter-spacing:-.02em}
    .sub{color:var(--sub);font-size:12px;line-height:1.55;margin-top:4px}
    .grid{margin-top:14px;display:grid;gap:14px;grid-template-columns: 1.25fr .75fr;}
    @media (max-width: 980px){ .grid{grid-template-columns:1fr;} }
    .card{
      border:1px solid var(--line);
      background: linear-gradient(180deg, rgba(255,255,255,.07), rgba(255,255,255,.03));
      border-radius: var(--r);
      box-shadow: var(--shadow);
      overflow:hidden;
    }
    .hd{
      padding:14px 14px 10px;
      border-bottom:1px solid rgba(255,255,255,.08);
      display:flex;justify-content:space-between;align-items:flex-start;gap:12px;flex-wrap:wrap;
      background: linear-gradient(180deg, rgba(255,255,255,.07), rgba(255,255,255,.00));
    }
    .title{font-weight:950;font-size:13px;letter-spacing:-.01em}
    .hint{color:var(--sub);font-size:12px;margin-top:6px;line-height:1.55}
    .bd{padding:14px;}
    .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
    .langWrap{
      display:flex;
      align-items:center;
      gap:8px;
      padding:8px 10px;
      border:1px solid rgba(255,255,255,.12);
      border-radius: 14px;
      background: rgba(255,255,255,.05);
    }
    .langSelect{
      min-width:130px;
      width:auto;
      padding:8px 10px;
      border-radius:10px;
      font-size:12px;
    }
    .btn{
      border:1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.06);
      color: var(--text);
      padding:10px 12px;
      border-radius: 14px;
      font-weight:900;
      cursor:pointer;
      transition:.15s transform,.15s background,.15s border-color;
      user-select:none;
      white-space:nowrap;
    }
    .btn:hover{transform: translateY(-1px); background: rgba(255,255,255,.10); border-color: rgba(255,255,255,.22); }
    .btn.primary{ background: linear-gradient(90deg, rgba(109,124,255,.28), rgba(53,240,181,.18)); border-color: rgba(109,124,255,.55); }
    .btn.gold{ background: linear-gradient(90deg, rgba(255,211,110,.26), rgba(109,124,255,.16)); border-color: rgba(255,211,110,.52); }
    .btn.danger{ background: rgba(255,91,122,.12); border-color: rgba(255,91,122,.45); }
    .pill{
      display:inline-flex;gap:8px;align-items:center;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.06);
      border-radius: 999px;
      padding: 6px 10px;
      font-size: 12px;
      margin: 6px 6px 0 0;
    }
    .dot{width:9px;height:9px;border-radius:999px;background:var(--good)}
    .dot.mid{background:var(--mid)}
    .dot.gold{background:var(--gold)}
    .canvasWrap{display:grid;gap:12px}
    .stage{
      position:relative;
      border-radius: 18px;
      border:1px solid rgba(255,255,255,.10);
      background: rgba(4,6,16,.55);
      overflow:hidden;
      touch-action:none;
    }
    canvas{
      width:100%;
      height:auto;
      display:block;
      background: transparent;
    }
    .sliderUI{
      position:absolute; inset:0;
      pointer-events:none;
    }
    .divider{
      position:absolute; top:0; bottom:0;
      width:3px;
      background: rgba(255,255,255,.85);
      box-shadow: 0 0 0 1px rgba(0,0,0,.25);
    }
    .handle{
      position:absolute; top:50%;
      width:46px; height:46px;
      border-radius: 999px;
      transform: translate(-50%, -50%);
      background: rgba(0,0,0,.45);
      border:1px solid rgba(255,255,255,.18);
      backdrop-filter: blur(10px);
      box-shadow: var(--shadow);
      display:flex;align-items:center;justify-content:center;
      color: rgba(255,255,255,.9);
      font-weight: 950;
      font-size: 18px;
    }
    .tag{
      position:absolute; top:12px;
      padding:6px 10px;
      border-radius:999px;
      font-size:12px;
      font-weight:950;
      border:1px solid rgba(255,255,255,.16);
      background: rgba(0,0,0,.35);
      color: rgba(255,255,255,.9);
      pointer-events:none;
    }
    .tag.left{left:12px}
    .tag.right{right:12px}
    .toggle{
      display:flex;gap:10px;flex-wrap:wrap;align-items:center;justify-content:space-between;
      padding:10px 12px;border-radius:18px;border:1px solid rgba(255,255,255,.10);background:rgba(255,255,255,.05);
    }
    .tiny{font-size:12px;color:var(--sub);line-height:1.6}
    .warn{
      margin-top:10px;
      padding:12px;
      border-radius:18px;
      border:1px solid rgba(255,211,110,.25);
      background: rgba(255,211,110,.06);
      color: var(--sub);
      font-size:12px;
      line-height:1.6;
    }
    .control{
      padding:12px;
      border-radius: 18px;
      border:1px solid rgba(255,255,255,.10);
      background: rgba(255,255,255,.05);
      margin-bottom:10px;
    }
    .control .top{display:flex;justify-content:space-between;gap:10px;align-items:center}
    .control .name{font-weight:950;font-size:12px}
    .control .val{font-size:12px;color:var(--sub);font-family:ui-monospace, Menlo, Monaco, Consolas, monospace}
    input[type="range"]{width:100%}
    select, input[type="color"]{
      width:100%;
      background: rgba(7,10,20,.62);
      border:1px solid rgba(255,255,255,.14);
      color: var(--text);
      border-radius: 14px;
      padding: 10px 12px;
      outline:none;
    }
    .split{display:grid;gap:10px;grid-template-columns:1fr 1fr}
    @media (max-width: 520px){ .split{grid-template-columns:1fr} }
    .mono{font-family: ui-monospace, Menlo, Monaco, Consolas, monospace;}
    .badge{
      display:inline-flex;align-items:center;gap:8px;
      font-size:12px;font-weight:950;
      padding:6px 10px;border-radius:999px;
      border:1px solid rgba(255,255,255,.14);
      background:rgba(255,255,255,.06);
      white-space:nowrap;
    }
    .k{display:flex;gap:8px;flex-wrap:wrap}
    .ck{display:flex;align-items:center;gap:8px}
    .ck input{accent-color:#7aa7ff}
    @media (max-width: 900px){
      .wrap{padding:12px 10px 20px;}
      .topbar{padding:12px; gap:10px;}
      h1{font-size:15px;}
      .row{width:100%;}
      .row .btn{flex:1 1 calc(50% - 6px); min-height:44px; text-align:center; justify-content:center;}
      .row label.btn{display:flex !important;}
      .langWrap{width:100%; justify-content:space-between;}
      .langSelect{flex:1;}
      .hd{padding:12px 12px 9px;}
      .bd{padding:12px;}
      .pill{font-size:11px;}
      .control{padding:10px;}
    }
    @media (max-width: 520px){
      .row .btn{flex:1 1 100%;}
      .handle{width:42px;height:42px;font-size:16px;}
      .tag{font-size:11px;padding:5px 8px;}
    }
  </style>
</head>

<body>
  <div class="wrap">
    <div class="topbar">
      <div class="brand">
        <div class="logo" aria-hidden="true"></div>
        <div>
          <h1><span id="appTitle">AIë·°í‹°ì‹œë®¬ë ˆì´í„°</span> <span id="appSubtitle" style="color:var(--sub);font-weight:800;">â€” ë” í‹° ë‚˜ê²Œ / Before-After ë“œë˜ê·¸</span></h1>
          <div class="sub" id="topSub">
            âœ… ë¸Œë¼ìš°ì €ì—ì„œë§Œ ì²˜ë¦¬(ì„œë²„ ì—…ë¡œë“œ ì—†ìŒ) Â· âœ… í—¤ì–´ìŠ¤íƒ€ì¼ ì˜¤ë²„ë ˆì´ + ì»¨íˆ¬ì–´/í•˜ì´ë¼ì´íŠ¸ ê°•í™” Â· âœ… ì°¸ê³ ìš© ì‹œë®¬ë ˆì´ì…˜
          </div>
        </div>
      </div>
      <div class="row">
        <div class="langWrap">
          <label class="tiny" id="lblLang" for="langSelect">ì–¸ì–´</label>
          <select id="langSelect" class="langSelect" aria-label="Language">
            <option value="ko">í•œêµ­ì–´</option>
            <option value="en">English</option>
            <option value="ja">æ—¥æœ¬èª</option>
            <option value="es">EspaÃ±ol</option>
            <option value="fr">FranÃ§ais</option>
            <option value="de">Deutsch</option>
          </select>
        </div>
        <button class="btn" id="btnUseCamera">ì¹´ë©”ë¼ ì‚¬ìš©</button>
        <label class="btn" style="display:inline-flex;align-items:center;gap:10px;">
          <span id="labelUpload">ì‚¬ì§„ ì—…ë¡œë“œ</span>
          <input id="file" type="file" accept="image/*" style="display:none">
        </label>
        <button class="btn gold" id="btnSave" disabled>ì´ë¯¸ì§€ ì €ì¥</button>
        <button class="btn danger" id="btnReset">ì´ˆê¸°í™”</button>
      </div>
    </div>

    <div class="grid">
      <!-- LEFT: PREVIEW -->
      <section class="card">
        <div class="hd">
          <div>
            <div class="title" id="previewTitle">ğŸª ë¯¸ë¦¬ë³´ê¸°</div>
            <div class="hint">
              <span class="pill"><span class="dot"></span><span id="pillCompare">ìŠ¬ë¼ì´ë” ë“œë˜ê·¸ë¡œ Before/After ë¹„êµ</span></span>
              <span class="pill"><span class="dot mid"></span><span id="pillDepth">ìœ¤ê³½ í•€ì¹˜ + ê´‘(í•˜ì´ë¼ì´íŠ¸)ë¡œ â€œ2.5D ì°©ì‹œâ€</span></span>
              <span class="pill"><span class="dot gold"></span><span id="pillHair">í—¤ì–´(ì•ë¨¸ë¦¬/ë‹¨ë°œ/ì¥ë°œ) ì˜¤ë²„ë ˆì´</span></span>
            </div>
          </div>
          <div class="row">
            <button class="btn primary" id="btnPresetNatural" disabled>í”„ë¦¬ì…‹: ìì—°</button>
            <button class="btn" id="btnPresetDramatic" disabled>í”„ë¦¬ì…‹: ë“œë¼ë§ˆí‹±</button>
            <button class="btn" id="btnPresetGlow" disabled>í”„ë¦¬ì…‹: ê´‘íƒ</button>
          </div>
        </div>
        <div class="bd">
          <div class="canvasWrap">
            <div class="stage" id="stage">
              <!-- result canvas -->
              <canvas id="view" width="1280" height="960"></canvas>

              <!-- UI overlay -->
              <div class="sliderUI" id="sliderUI">
                <div class="tag left" id="tagBefore">BEFORE</div>
                <div class="tag right" id="tagAfter">AFTER</div>
                <div class="divider" id="divider"></div>
                <div class="handle" id="handle">â†”</div>
              </div>
            </div>

            <div class="toggle">
              <div class="tiny">
                <span class="badge" id="tipBadge">íŒ</span>
                <span id="tipText">â€œê°•ë„â€ë¥¼ 60~80ìœ¼ë¡œ ì˜¬ë¦¬ë©´ í›¨ì”¬ <b>í‹°</b>ê°€ ë‚˜ê³ , â€œí—¤ì–´ ìŠ¤íƒ€ì¼â€ì„ ë°”ê¾¸ë©´ ì²´ê°ì´ í™• ì»¤ì ¸ìš”.</span>
              </div>
              <div class="k">
                <label class="ck tiny"><input type="checkbox" id="chkMirror" checked> <span id="lblMirror">ê±°ìš¸</span></label>
                <label class="ck tiny"><input type="checkbox" id="chkLandmarks"> <span id="lblLandmarks">ëœë“œë§ˆí¬</span></label>
                <label class="ck tiny"><input type="checkbox" id="chkHQ" checked> <span id="lblHQ">ê³ í™”ì§ˆ</span></label>
              </div>
            </div>

            <div class="warn" id="warnText">
              <b id="warnTitle">ë©´ì±…</b> : <span id="warnBody">ë³¸ ì„œë¹„ìŠ¤ëŠ” ì˜¤ë½ ë° ìŠ¤íƒ€ì¼ ì°¸ê³ ìš© ì‹œë®¬ë ˆì´ì…˜ì…ë‹ˆë‹¤. ì‹¤ì œ ì‹œìˆ /ìˆ˜ìˆ  ê²°ê³¼ë¥¼ ì˜ˆì¸¡í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.</span>
            </div>
          </div>
        </div>
      </section>

      <!-- RIGHT: CONTROLS -->
      <aside class="card">
        <div class="hd">
          <div>
            <div class="title" id="controlsTitle">ğŸ›ï¸ â€œë” í‹° ë‚˜ê²Œâ€ ì»¨íŠ¸ë¡¤</div>
            <div class="hint" id="controlsHint">ì´ ë²„ì „ì€ ì¼ë¶€ëŸ¬ ì²´ê°ì´ í¬ê²Œ ë‚˜ë„ë¡(ê³¼ê°) ê¸°ë³¸ê°’/íš¨ê³¼ë¥¼ ê°•í™”í–ˆìŠµë‹ˆë‹¤.</div>
          </div>
        </div>

        <div class="bd">
          <div class="control">
            <div class="top"><div class="name">ì „ì²´ ê°•ë„</div><div class="val" id="vPower">65</div></div>
            <input type="range" id="power" min="0" max="100" value="65">
            <div class="desc">ëª¨ë“  ë³€í˜•/ë©”ì´í¬ì—…/ìœ¤ê³½ íš¨ê³¼ì˜ â€œë§ˆìŠ¤í„° ê²Œì¸â€</div>
          </div>

          <div class="split">
            <div class="control">
              <div class="top"><div class="name">ëˆˆ í¬ê¸°</div><div class="val" id="vEye">20</div></div>
              <input type="range" id="eye" min="-40" max="80" value="20">
              <div class="desc">ëˆˆ í™•ëŒ€/ì¶•ì†Œ</div>
            </div>
            <div class="control">
              <div class="top"><div class="name">ëˆˆ ê°„ê²©</div><div class="val" id="vEyeSpace">6</div></div>
              <input type="range" id="eyeSpace" min="-40" max="40" value="6">
              <div class="desc">ëˆˆì„ ì•ˆ/ë°–ìœ¼ë¡œ ì´ë™</div>
            </div>
          </div>

          <div class="split">
            <div class="control">
              <div class="top"><div class="name">ì½” í­</div><div class="val" id="vNoseW">-10</div></div>
              <input type="range" id="noseW" min="-55" max="55" value="-10">
              <div class="desc">ì½§ë³¼ ëŠë‚Œ(ê°€ë¡œ ì›Œí”„)</div>
            </div>
            <div class="control">
              <div class="top"><div class="name">ì½” â€˜ë†’ì•„ë³´ì„â€™</div><div class="val" id="vNoseH">45</div></div>
              <input type="range" id="noseH" min="0" max="100" value="45">
              <div class="desc">ì½§ëŒ€ í•˜ì´ë¼ì´íŠ¸ + ì–‘ì˜† ì‰ë”© ê°•í™”</div>
            </div>
          </div>

          <div class="split">
            <div class="control">
              <div class="top"><div class="name">ì…ìˆ  ë³¼ë¥¨</div><div class="val" id="vLip">18</div></div>
              <input type="range" id="lip" min="-40" max="65" value="18">
              <div class="desc">ì…ìˆ  í™•ëŒ€/ì¶•ì†Œ</div>
            </div>
            <div class="control">
              <div class="top"><div class="name">í„±/ìœ¤ê³½</div><div class="val" id="vSlim">35</div></div>
              <input type="range" id="slim" min="0" max="100" value="35">
              <div class="desc">ë³¼/í„± ë¼ì¸ì„ ì¤‘ì•™ìœ¼ë¡œ í•€ì¹˜(ì²´ê° í¼)</div>
            </div>
          </div>

          <div class="split">
            <div class="control">
              <div class="top"><div class="name">í”¼ë¶€ ë³´ì •</div><div class="val" id="vSkin">35</div></div>
              <input type="range" id="skin" min="0" max="100" value="35">
              <div class="desc">ì–¼êµ´ ì˜ì—­ ìŠ¤ë¬´ë”© + í†¤</div>
            </div>
            <div class="control">
              <div class="top"><div class="name">ì»¨íˆ¬ì–´(ì‰ë”©)</div><div class="val" id="vContour">35</div></div>
              <input type="range" id="contour" min="0" max="100" value="35">
              <div class="desc">ê´‘ëŒ€/í„±/ì½” ì˜† ì‰ë”©</div>
            </div>
          </div>

          <div class="split">
            <div class="control">
              <div class="top"><div class="name">ë¸”ëŸ¬ì…”</div><div class="val" id="vBlush">30</div></div>
              <input type="range" id="blush" min="0" max="100" value="30">
              <div class="desc">ì¹˜í¬ ì»¬ëŸ¬</div>
            </div>
            <div class="control">
              <div class="top"><div class="name">ì•„ì´ë¼ì¸</div><div class="val" id="vLiner">45</div></div>
              <input type="range" id="liner" min="0" max="100" value="45">
              <div class="desc">ìœ—ë¼ì¸/ëˆˆê¼¬ë¦¬ ê°•ì¡°</div>
            </div>
          </div>

          <div class="split">
            <div class="control">
              <div class="top"><div class="name">ë¦½ ì»¬ëŸ¬</div><div class="val" id="vLipColor">#ff3e7a</div></div>
              <input type="color" id="lipColor" value="#ff3e7a">
              <div class="desc">ì…ìˆ  ìƒ‰ìƒ</div>
            </div>
            <div class="control">
              <div class="top"><div class="name">ë¦½ ê¸€ë¡œìŠ¤</div><div class="val" id="vGloss">35</div></div>
              <input type="range" id="gloss" min="0" max="100" value="35">
              <div class="desc">ì…ìˆ  ê´‘(2.5D ì²´ê°â†‘)</div>
            </div>
          </div>

          <div class="control">
            <div class="top"><div class="name">í—¤ì–´ ìŠ¤íƒ€ì¼</div><div class="val" id="vHairStyle">ì•ë¨¸ë¦¬</div></div>
            <select id="hairStyle">
              <option value="none">ì—†ìŒ</option>
              <option value="bangs" selected>ì•ë¨¸ë¦¬</option>
              <option value="bob">ë‹¨ë°œ(ë³´ë¸Œ)</option>
              <option value="long">ì¥ë°œ</option>
            </select>
            <div class="desc">ì •ë°€ ì„¸ê·¸ë©˜í…Œì´ì…˜ ëŒ€ì‹  â€œì–¼êµ´ ì™¸ê³½/ì´ë§ˆ í¬ì¸íŠ¸â€ ê¸°ë°˜ìœ¼ë¡œ ê·¸ëŸ´ë“¯í•œ ì˜¤ë²„ë ˆì´ë¥¼ ë§Œë“­ë‹ˆë‹¤(í‹° ë§ì´ ë‚¨).</div>
          </div>

          <div class="split">
            <div class="control">
              <div class="top"><div class="name">í—¤ì–´ ì»¬ëŸ¬</div><div class="val" id="vHairColor">#2b1a14</div></div>
              <input type="color" id="hairColor" value="#2b1a14">
              <div class="desc">í—¤ì–´ ì˜¤ë²„ë ˆì´ ìƒ‰</div>
            </div>
            <div class="control">
              <div class="top"><div class="name">ì•…ì„¸ì„œë¦¬</div><div class="val" id="vAcc">ON</div></div>
              <label class="ck tiny"><input type="checkbox" id="glasses" checked> <span id="lblGlasses">ì•ˆê²½</span></label>
              <label class="ck tiny"><input type="checkbox" id="earrings" checked> <span id="lblEarrings">ê·€ê±¸ì´</span></label>
              <div class="desc">ëˆˆ/í„± ìœ„ì¹˜ ê¸°ë°˜ ì˜¤ë²„ë ˆì´</div>
            </div>
          </div>

          <div class="tiny" style="margin-top:12px;" id="shootTipText">
            <b id="shootTipTitle">ì´¬ì˜ íŒ</b><br/>
            <span id="shootTipBody">ì •ë©´ + ë°ì€ ì¡°ëª… + ì–¼êµ´ì´ í¬ê²Œ ë‚˜ì˜¤ë©´(ì´ë§ˆ~í„±) í›¨ì”¬ ìì—°ìŠ¤ëŸ½ê³  í‹°ê°€ ì˜ ë‚©ë‹ˆë‹¤.</span>
          </div>
        </div>
      </aside>
    </div>
  </div>

  <video id="video" playsinline style="display:none"></video>
  <canvas id="src" width="1280" height="960" style="display:none"></canvas>

  <!-- MediaPipe -->
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

  <script>
    // =========================================================
    // â€œë” í‹° ë‚˜ê²Œâ€ í¬ì¸íŠ¸
    // 1) Before/After ë“œë˜ê·¸ ìŠ¬ë¼ì´ë”(ì²´ê° í­ë°œ)
    // 2) ìœ¤ê³½ í•€ì¹˜(ì†Œí”„íŠ¸ ì›Œí”„) + ì»¨íˆ¬ì–´/í•˜ì´ë¼ì´íŠ¸ ê°•í™”ë¡œ 2.5D ì°©ì‹œ
    // 3) í—¤ì–´ìŠ¤íƒ€ì¼(ì•ë¨¸ë¦¬/ë‹¨ë°œ/ì¥ë°œ) ì˜¤ë²„ë ˆì´: ë³€í™”ê°€ ê°€ì¥ ëˆˆì— ë„ëŠ” ìš”ì†Œ
    // =========================================================

    const view = $('view');
    const vctx = view.getContext('2d');

    const src = $('src');
    const sctx = src.getContext('2d');

    const video = $('video');
    const file = $('file');

    // offscreen: before/after render
    const beforeC = document.createElement('canvas');
    beforeC.width = view.width; beforeC.height = view.height;
    const bctx = beforeC.getContext('2d');

    const afterC = document.createElement('canvas');
    afterC.width = view.width; afterC.height = view.height;
    const actx = afterC.getContext('2d');

    const stage = $('stage');
    const divider = $('divider');
    const handle = $('handle');
    const langSelect = $('langSelect');

    let splitX = 0.55; // 0..1
    let dragging = false;

    // UI elements
    const chkMirror = $('chkMirror');
    const chkLandmarks = $('chkLandmarks');
    const chkHQ = $('chkHQ');

    const btnUseCamera = $('btnUseCamera');
    const btnSave = $('btnSave');
    const btnReset = $('btnReset');

    const btnPresetNatural = $('btnPresetNatural');
    const btnPresetDramatic = $('btnPresetDramatic');
    const btnPresetGlow = $('btnPresetGlow');

    // controls
    const power = $('power');
    const eye = $('eye'), eyeSpace = $('eyeSpace');
    const noseW = $('noseW'), noseH = $('noseH');
    const lip = $('lip'), slim = $('slim');
    const skin = $('skin'), contour = $('contour'), blush = $('blush'), liner = $('liner'), gloss = $('gloss');
    const lipColor = $('lipColor');
    const hairStyle = $('hairStyle');
    const hairColor = $('hairColor');
    const glasses = $('glasses');
    const earrings = $('earrings');

    // value labels
    const vPower = $('vPower');
    const vEye = $('vEye'), vEyeSpace = $('vEyeSpace');
    const vNoseW = $('vNoseW'), vNoseH = $('vNoseH');
    const vLip = $('vLip'), vSlim = $('vSlim');
    const vSkin = $('vSkin'), vContour = $('vContour'), vBlush = $('vBlush'), vLiner = $('vLiner'), vGloss = $('vGloss');
    const vLipColor = $('vLipColor'), vHairStyle = $('vHairStyle'), vHairColor = $('vHairColor'), vAcc = $('vAcc');
    const controlNameEls = Array.from(document.querySelectorAll('.control .name'));
    const controlDescEls = Array.from(document.querySelectorAll('.control .desc'));

    function $(id){ return document.getElementById(id); }

    let usingCamera = false;
    let camera = null;
    let lastLandmarks = null;
    let lastFrameCanvas = null;
    let lastProcessAt = 0;
    let currentLang = 'ko';

    const I18N = {
      ko: {
        htmlLang: 'ko',
        docTitle: 'AIë·°í‹°ì‹œë®¬ë ˆì´í„° â€” ë” í‹° ë‚˜ê²Œ (Before/After ìŠ¬ë¼ì´ë”)',
        docDesc: 'ë‚´ ì‚¬ì§„ìœ¼ë¡œ ëˆˆ/ì½”/ì…/ìœ¤ê³½ ì›Œí”„ + ì»¨íˆ¬ì–´/í•˜ì´ë¼ì´íŠ¸/ì•„ì´ë¼ì¸/ë¦½/ë¸”ëŸ¬ì…” + í—¤ì–´ìŠ¤íƒ€ì¼ ì˜¤ë²„ë ˆì´ê¹Œì§€.',
        appTitle: 'AIë·°í‹°ì‹œë®¬ë ˆì´í„°',
        appSubtitle: 'â€” ë” í‹° ë‚˜ê²Œ / Before-After ë“œë˜ê·¸',
        topSub: 'âœ… ë¸Œë¼ìš°ì €ì—ì„œë§Œ ì²˜ë¦¬(ì„œë²„ ì—…ë¡œë“œ ì—†ìŒ) Â· âœ… í—¤ì–´ìŠ¤íƒ€ì¼ ì˜¤ë²„ë ˆì´ + ì»¨íˆ¬ì–´/í•˜ì´ë¼ì´íŠ¸ ê°•í™” Â· âœ… ì°¸ê³ ìš© ì‹œë®¬ë ˆì´ì…˜',
        langLabel: 'ì–¸ì–´',
        btnCamera: 'ì¹´ë©”ë¼ ì‚¬ìš©',
        btnUpload: 'ì‚¬ì§„ ì—…ë¡œë“œ',
        btnSave: 'ì´ë¯¸ì§€ ì €ì¥',
        btnReset: 'ì´ˆê¸°í™”',
        previewTitle: 'ğŸª ë¯¸ë¦¬ë³´ê¸°',
        pillCompare: 'ìŠ¬ë¼ì´ë” ë“œë˜ê·¸ë¡œ Before/After ë¹„êµ',
        pillDepth: 'ìœ¤ê³½ í•€ì¹˜ + ê´‘(í•˜ì´ë¼ì´íŠ¸)ë¡œ â€œ2.5D ì°©ì‹œâ€',
        pillHair: 'í—¤ì–´(ì•ë¨¸ë¦¬/ë‹¨ë°œ/ì¥ë°œ) ì˜¤ë²„ë ˆì´',
        presetNatural: 'í”„ë¦¬ì…‹: ìì—°',
        presetDramatic: 'í”„ë¦¬ì…‹: ë“œë¼ë§ˆí‹±',
        presetGlow: 'í”„ë¦¬ì…‹: ê´‘íƒ',
        tagBefore: 'BEFORE',
        tagAfter: 'AFTER',
        tipBadge: 'íŒ',
        tipText: 'â€œê°•ë„â€ë¥¼ 60~80ìœ¼ë¡œ ì˜¬ë¦¬ë©´ í›¨ì”¬ <b>í‹°</b>ê°€ ë‚˜ê³ , â€œí—¤ì–´ ìŠ¤íƒ€ì¼â€ì„ ë°”ê¾¸ë©´ ì²´ê°ì´ í™• ì»¤ì ¸ìš”.',
        lblMirror: 'ê±°ìš¸',
        lblLandmarks: 'ëœë“œë§ˆí¬',
        lblHQ: 'ê³ í™”ì§ˆ',
        warnTitle: 'ë©´ì±…',
        warnBody: 'ë³¸ ì„œë¹„ìŠ¤ëŠ” ì˜¤ë½ ë° ìŠ¤íƒ€ì¼ ì°¸ê³ ìš© ì‹œë®¬ë ˆì´ì…˜ì…ë‹ˆë‹¤. ì‹¤ì œ ì‹œìˆ /ìˆ˜ìˆ  ê²°ê³¼ë¥¼ ì˜ˆì¸¡í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.',
        controlsTitle: 'ğŸ›ï¸ â€œë” í‹° ë‚˜ê²Œâ€ ì»¨íŠ¸ë¡¤',
        controlsHint: 'ì´ ë²„ì „ì€ ì¼ë¶€ëŸ¬ ì²´ê°ì´ í¬ê²Œ ë‚˜ë„ë¡(ê³¼ê°) ê¸°ë³¸ê°’/íš¨ê³¼ë¥¼ ê°•í™”í–ˆìŠµë‹ˆë‹¤.',
        controlNames: ['ì „ì²´ ê°•ë„', 'ëˆˆ í¬ê¸°', 'ëˆˆ ê°„ê²©', 'ì½” í­', 'ì½” â€˜ë†’ì•„ë³´ì„â€™', 'ì…ìˆ  ë³¼ë¥¨', 'í„±/ìœ¤ê³½', 'í”¼ë¶€ ë³´ì •', 'ì»¨íˆ¬ì–´(ì‰ë”©)', 'ë¸”ëŸ¬ì…”', 'ì•„ì´ë¼ì¸', 'ë¦½ ì»¬ëŸ¬', 'ë¦½ ê¸€ë¡œìŠ¤', 'í—¤ì–´ ìŠ¤íƒ€ì¼', 'í—¤ì–´ ì»¬ëŸ¬', 'ì•…ì„¸ì„œë¦¬'],
        controlDescs: ['ëª¨ë“  ë³€í˜•/ë©”ì´í¬ì—…/ìœ¤ê³½ íš¨ê³¼ì˜ â€œë§ˆìŠ¤í„° ê²Œì¸â€', 'ëˆˆ í™•ëŒ€/ì¶•ì†Œ', 'ëˆˆì„ ì•ˆ/ë°–ìœ¼ë¡œ ì´ë™', 'ì½§ë³¼ ëŠë‚Œ(ê°€ë¡œ ì›Œí”„)', 'ì½§ëŒ€ í•˜ì´ë¼ì´íŠ¸ + ì–‘ì˜† ì‰ë”© ê°•í™”', 'ì…ìˆ  í™•ëŒ€/ì¶•ì†Œ', 'ë³¼/í„± ë¼ì¸ì„ ì¤‘ì•™ìœ¼ë¡œ í•€ì¹˜(ì²´ê° í¼)', 'ì–¼êµ´ ì˜ì—­ ìŠ¤ë¬´ë”© + í†¤', 'ê´‘ëŒ€/í„±/ì½” ì˜† ì‰ë”©', 'ì¹˜í¬ ì»¬ëŸ¬', 'ìœ—ë¼ì¸/ëˆˆê¼¬ë¦¬ ê°•ì¡°', 'ì…ìˆ  ìƒ‰ìƒ', 'ì…ìˆ  ê´‘(2.5D ì²´ê°â†‘)', 'ì •ë°€ ì„¸ê·¸ë©˜í…Œì´ì…˜ ëŒ€ì‹  â€œì–¼êµ´ ì™¸ê³½/ì´ë§ˆ í¬ì¸íŠ¸â€ ê¸°ë°˜ìœ¼ë¡œ ê·¸ëŸ´ë“¯í•œ ì˜¤ë²„ë ˆì´ë¥¼ ë§Œë“­ë‹ˆë‹¤(í‹° ë§ì´ ë‚¨).', 'í—¤ì–´ ì˜¤ë²„ë ˆì´ ìƒ‰', 'ëˆˆ/í„± ìœ„ì¹˜ ê¸°ë°˜ ì˜¤ë²„ë ˆì´'],
        hairOptions: ['ì—†ìŒ', 'ì•ë¨¸ë¦¬', 'ë‹¨ë°œ(ë³´ë¸Œ)', 'ì¥ë°œ'],
        lblGlasses: 'ì•ˆê²½',
        lblEarrings: 'ê·€ê±¸ì´',
        accOn: 'ON',
        accOff: 'OFF',
        shootTipTitle: 'ì´¬ì˜ íŒ',
        shootTipBody: 'ì •ë©´ + ë°ì€ ì¡°ëª… + ì–¼êµ´ì´ í¬ê²Œ ë‚˜ì˜¤ë©´(ì´ë§ˆ~í„±) í›¨ì”¬ ìì—°ìŠ¤ëŸ½ê³  í‹°ê°€ ì˜ ë‚©ë‹ˆë‹¤.',
        hintUpload: 'ì‚¬ì§„ì„ ì—…ë¡œë“œí•˜ê±°ë‚˜ ì¹´ë©”ë¼ë¥¼ ì¼œì£¼ì„¸ìš”.',
        cameraPermission: 'ì¹´ë©”ë¼ ê¶Œí•œì„ í—ˆìš©í•´ì•¼ ì‚¬ìš©í•  ìˆ˜ ìˆì–´ìš”.'
      },
      en: {
        htmlLang: 'en',
        docTitle: 'AI Beauty Simulator â€” Dramatic Before/After Slider',
        docDesc: 'Eye/Nose/Lip/Contour warp with contour, highlight, eyeliner, lipstick, blush and hair overlays.',
        appTitle: 'AI Beauty Simulator',
        appSubtitle: 'â€” More Dramatic / Before-After Drag',
        topSub: 'âœ… In-browser only (no server upload) Â· âœ… Hair overlay + stronger contour/highlight Â· âœ… Simulation for reference',
        langLabel: 'Language',
        btnCamera: 'Use Camera',
        btnUpload: 'Upload Photo',
        btnSave: 'Save Image',
        btnReset: 'Reset',
        previewTitle: 'ğŸª Preview',
        pillCompare: 'Drag slider to compare Before/After',
        pillDepth: 'Contour pinch + highlight for a â€œ2.5Dâ€ depth illusion',
        pillHair: 'Hair overlay (bangs / bob / long)',
        presetNatural: 'Preset: Natural',
        presetDramatic: 'Preset: Dramatic',
        presetGlow: 'Preset: Glow',
        tagBefore: 'BEFORE',
        tagAfter: 'AFTER',
        tipBadge: 'Tip',
        tipText: 'Set â€œPowerâ€ to 60~80 and switch â€œHair Styleâ€ for a much stronger visible change.',
        lblMirror: 'Mirror',
        lblLandmarks: 'Landmarks',
        lblHQ: 'High Quality',
        warnTitle: 'Disclaimer',
        warnBody: 'This simulator is for entertainment/reference only. Actual cosmetic or styling outcomes may differ.',
        controlsTitle: 'ğŸ›ï¸ Dramatic Controls',
        controlsHint: 'This version intentionally boosts defaults for more visible changes.',
        controlNames: ['Master Power', 'Eye Size', 'Eye Spacing', 'Nose Width', 'Nose Height Look', 'Lip Volume', 'Jaw/Contour', 'Skin Smoothing', 'Contour (Shading)', 'Blush', 'Eyeliner', 'Lip Color', 'Lip Gloss', 'Hair Style', 'Hair Color', 'Accessories'],
        controlDescs: ['Master gain for all warps and makeup effects', 'Enlarge/reduce eyes', 'Move eyes inward/outward', 'Nostril width feel (horizontal warp)', 'Bridge highlight + side shading', 'Enlarge/reduce lips', 'Pinch cheek/jaw lines inward', 'Face region smoothing + tone', 'Cheek/jaw/nose-side shading', 'Cheek color', 'Upper line and tail emphasis', 'Lip color', 'Gloss highlight (2.5D boost)', 'Approximate overlay based on face outline/forehead points', 'Hair overlay color', 'Eye/jaw-based overlay accessories'],
        hairOptions: ['None', 'Bangs', 'Bob', 'Long'],
        lblGlasses: 'Glasses',
        lblEarrings: 'Earrings',
        accOn: 'ON',
        accOff: 'OFF',
        shootTipTitle: 'Capture Tip',
        shootTipBody: 'Front-facing, bright lighting, and a larger face area in frame gives better results.',
        hintUpload: 'Upload a photo or turn on the camera.',
        cameraPermission: 'Camera permission is required to use this feature.'
      },
      ja: {
        htmlLang: 'ja',
        docTitle: 'AIãƒ“ãƒ¥ãƒ¼ãƒ†ã‚£ãƒ¼ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚¿ãƒ¼ â€” Before/After ã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼',
        docDesc: 'ç›®ãƒ»é¼»ãƒ»å”‡ãƒ»è¼ªéƒ­ãƒ¯ãƒ¼ãƒ—ã¨ã€ã‚³ãƒ³ãƒˆã‚¥ã‚¢/ãƒã‚¤ãƒ©ã‚¤ãƒˆ/ã‚¢ã‚¤ãƒ©ã‚¤ãƒ³/ãƒªãƒƒãƒ—/ãƒãƒ¼ã‚¯ã€ãƒ˜ã‚¢é‡ã­åˆã‚ã›ã€‚',
        appTitle: 'AIãƒ“ãƒ¥ãƒ¼ãƒ†ã‚£ãƒ¼ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚¿ãƒ¼',
        appSubtitle: 'â€” å¤‰åŒ–ã‚’å¼·ã‚ã« / Before-After ãƒ‰ãƒ©ãƒƒã‚°',
        topSub: 'âœ… ãƒ–ãƒ©ã‚¦ã‚¶å†…å‡¦ç†ã®ã¿ï¼ˆã‚µãƒ¼ãƒãƒ¼ä¿å­˜ãªã—ï¼‰ Â· âœ… ãƒ˜ã‚¢é‡ã­åˆã‚ã› + å¼·èª¿ãƒ¡ã‚¤ã‚¯ Â· âœ… å‚è€ƒç”¨ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³',
        langLabel: 'è¨€èª',
        btnCamera: 'ã‚«ãƒ¡ãƒ©ã‚’ä½¿ã†',
        btnUpload: 'å†™çœŸã‚’ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰',
        btnSave: 'ç”»åƒã‚’ä¿å­˜',
        btnReset: 'ãƒªã‚»ãƒƒãƒˆ',
        previewTitle: 'ğŸª ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼',
        pillCompare: 'ã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼ã§ Before/After æ¯”è¼ƒ',
        pillDepth: 'è¼ªéƒ­ãƒ”ãƒ³ãƒ + ãƒã‚¤ãƒ©ã‚¤ãƒˆã§ 2.5D ç«‹ä½“æ„Ÿ',
        pillHair: 'ãƒ˜ã‚¢é‡ã­åˆã‚ã›ï¼ˆå‰é«ª / ãƒœãƒ– / ãƒ­ãƒ³ã‚°ï¼‰',
        presetNatural: 'ãƒ—ãƒªã‚»ãƒƒãƒˆ: ãƒŠãƒãƒ¥ãƒ©ãƒ«',
        presetDramatic: 'ãƒ—ãƒªã‚»ãƒƒãƒˆ: ãƒ‰ãƒ©ãƒãƒãƒƒã‚¯',
        presetGlow: 'ãƒ—ãƒªã‚»ãƒƒãƒˆ: ãƒ„ãƒ¤',
        tagBefore: 'BEFORE',
        tagAfter: 'AFTER',
        tipBadge: 'ãƒ’ãƒ³ãƒˆ',
        tipText: 'ã€Œå¼·åº¦ã€ã‚’60ã€œ80ã«ä¸Šã’ã¦ã€Œãƒ˜ã‚¢ã‚¹ã‚¿ã‚¤ãƒ«ã€ã‚’å¤‰ãˆã‚‹ã¨ã€é•ã„ãŒã‚ˆã‚Šã¯ã£ãã‚Šå‡ºã¾ã™ã€‚',
        lblMirror: 'ãƒŸãƒ©ãƒ¼',
        lblLandmarks: 'ãƒ©ãƒ³ãƒ‰ãƒãƒ¼ã‚¯',
        lblHQ: 'é«˜ç”»è³ª',
        warnTitle: 'å…è²¬',
        warnBody: 'æœ¬ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚¿ãƒ¼ã¯å¨¯æ¥½ãƒ»å‚è€ƒç”¨ã§ã™ã€‚å®Ÿéš›ã®æ–½è¡“/ã‚¹ã‚¿ã‚¤ãƒªãƒ³ã‚°çµæœã¨ã¯ç•°ãªã‚‹å ´åˆãŒã‚ã‚Šã¾ã™ã€‚',
        controlsTitle: 'ğŸ›ï¸ å¼·èª¿ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«',
        controlsHint: 'ä½“æ„Ÿå·®ãŒå‡ºã‚‹ã‚ˆã†ã€åŠ¹æœã‚’å¼·ã‚ã«è¨­å®šã—ã¦ã„ã¾ã™ã€‚',
        controlNames: ['å…¨ä½“å¼·åº¦', 'ç›®ã®å¤§ãã•', 'ç›®ã®é–“éš”', 'é¼»å¹…', 'é¼»ã‚’é«˜ãè¦‹ã›ã‚‹', 'å”‡ãƒœãƒªãƒ¥ãƒ¼ãƒ ', 'é¡/è¼ªéƒ­', 'è‚Œè£œæ­£', 'ã‚³ãƒ³ãƒˆã‚¥ã‚¢', 'ãƒãƒ¼ã‚¯', 'ã‚¢ã‚¤ãƒ©ã‚¤ãƒ³', 'ãƒªãƒƒãƒ—ã‚«ãƒ©ãƒ¼', 'ãƒªãƒƒãƒ—ã‚°ãƒ­ã‚¹', 'ãƒ˜ã‚¢ã‚¹ã‚¿ã‚¤ãƒ«', 'ãƒ˜ã‚¢ã‚«ãƒ©ãƒ¼', 'ã‚¢ã‚¯ã‚»ã‚µãƒªãƒ¼'],
        controlDescs: ['å…¨ä½“åŠ¹æœã®ãƒã‚¹ã‚¿ãƒ¼ã‚²ã‚¤ãƒ³', 'ç›®ã‚’æ‹¡å¤§/ç¸®å°', 'ç›®ã‚’å†…å´/å¤–å´ã«ç§»å‹•', 'å°é¼»ã®æ¨ªæ–¹å‘ãƒ¯ãƒ¼ãƒ—', 'é¼»ç­‹ãƒã‚¤ãƒ©ã‚¤ãƒˆ + ã‚µã‚¤ãƒ‰ã‚·ã‚§ãƒ¼ãƒ‰', 'å”‡ã‚’æ‹¡å¤§/ç¸®å°', 'é ¬/é¡ãƒ©ã‚¤ãƒ³ã‚’å†…å´ã«ãƒ”ãƒ³ãƒ', 'é¡”é ˜åŸŸã®ã‚¹ãƒ ãƒ¼ã‚¸ãƒ³ã‚° + ãƒˆãƒ¼ãƒ³', 'é ¬éª¨/é¡/é¼»æ¨ªã®é™°å½±', 'ãƒãƒ¼ã‚¯ã‚«ãƒ©ãƒ¼', 'ä¸Šã¾ã¶ãŸãƒ©ã‚¤ãƒ³å¼·èª¿', 'å”‡ã®è‰²', 'å”‡ã®ãƒ„ãƒ¤', 'é¡”è¼ªéƒ­/é¡ãƒã‚¤ãƒ³ãƒˆã«åŸºã¥ãé‡ã­åˆã‚ã›', 'ãƒ˜ã‚¢é‡ã­åˆã‚ã›ã®è‰²', 'ç›®/é¡ä½ç½®ãƒ™ãƒ¼ã‚¹ã®ã‚¢ã‚¯ã‚»ã‚µãƒªãƒ¼'],
        hairOptions: ['ãªã—', 'å‰é«ª', 'ãƒœãƒ–', 'ãƒ­ãƒ³ã‚°'],
        lblGlasses: 'ãƒ¡ã‚¬ãƒ',
        lblEarrings: 'ã‚¤ãƒ¤ãƒªãƒ³ã‚°',
        accOn: 'ON',
        accOff: 'OFF',
        shootTipTitle: 'æ’®å½±ã®ã‚³ãƒ„',
        shootTipBody: 'æ­£é¢ + æ˜ã‚‹ã„ç…§æ˜ + é¡”ãŒå¤§ããå†™ã‚‹æ§‹å›³ã§è‡ªç„¶ã«è¦‹ãˆã¾ã™ã€‚',
        hintUpload: 'å†™çœŸã‚’ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã™ã‚‹ã‹ã€ã‚«ãƒ¡ãƒ©ã‚’ã‚ªãƒ³ã«ã—ã¦ãã ã•ã„ã€‚',
        cameraPermission: 'ã‚«ãƒ¡ãƒ©æ¨©é™ã‚’è¨±å¯ã™ã‚‹ã¨åˆ©ç”¨ã§ãã¾ã™ã€‚'
      },
      es: {
        htmlLang: 'es',
        docTitle: 'Simulador de Belleza AI â€” Deslizador Before/After',
        docDesc: 'Warp de ojos/nariz/labios/contorno con contour, highlight, delineado, labial, rubor y peinados.',
        appTitle: 'Simulador de Belleza AI',
        appSubtitle: 'â€” MÃ¡s Notorio / Arrastrar Before-After',
        topSub: 'âœ… Solo en navegador (sin subir al servidor) Â· âœ… SuperposiciÃ³n de peinado + contour/highlight reforzado Â· âœ… SimulaciÃ³n de referencia',
        langLabel: 'Idioma',
        btnCamera: 'Usar CÃ¡mara',
        btnUpload: 'Subir Foto',
        btnSave: 'Guardar Imagen',
        btnReset: 'Reiniciar',
        previewTitle: 'ğŸª Vista previa',
        pillCompare: 'Arrastra para comparar Before/After',
        pillDepth: 'Pinch de contorno + highlight para efecto 2.5D',
        pillHair: 'SuperposiciÃ³n de cabello (flequillo / bob / largo)',
        presetNatural: 'Preset: Natural',
        presetDramatic: 'Preset: DramÃ¡tico',
        presetGlow: 'Preset: Glow',
        tagBefore: 'ANTES',
        tagAfter: 'DESPUÃ‰S',
        tipBadge: 'Tip',
        tipText: 'Sube â€œPotenciaâ€ a 60~80 y cambia â€œPeinadoâ€ para notar mÃ¡s diferencia.',
        lblMirror: 'Espejo',
        lblLandmarks: 'Puntos',
        lblHQ: 'Alta Calidad',
        warnTitle: 'Aviso',
        warnBody: 'Este simulador es solo para entretenimiento/referencia. El resultado real puede variar.',
        controlsTitle: 'ğŸ›ï¸ Controles Intensos',
        controlsHint: 'Esta versiÃ³n eleva los valores por defecto para un cambio mÃ¡s visible.',
        controlNames: ['Potencia Global', 'TamaÃ±o de Ojos', 'SeparaciÃ³n de Ojos', 'Ancho de Nariz', 'Nariz MÃ¡s Alta', 'Volumen de Labios', 'MandÃ­bula/Contorno', 'Suavizado de Piel', 'Contour (Sombra)', 'Rubor', 'Delineado', 'Color de Labios', 'Brillo de Labios', 'Peinado', 'Color de Cabello', 'Accesorios'],
        controlDescs: ['Ganancia maestra de todos los efectos', 'Aumentar/reducir ojos', 'Mover ojos hacia dentro/fuera', 'Warp horizontal de nariz', 'Highlight de puente + sombra lateral', 'Aumentar/reducir labios', 'Pinzar mejilla/mandÃ­bula al centro', 'Suavizado y tono en rostro', 'Sombra en pÃ³mulo/mandÃ­bula/nariz', 'Color de mejilla', 'Ã‰nfasis en lÃ­nea superior y cola', 'Color de labios', 'Brillo para efecto 2.5D', 'SuperposiciÃ³n aproximada por contorno facial', 'Color de superposiciÃ³n de cabello', 'Accesorios segÃºn ojos/mandÃ­bula'],
        hairOptions: ['Ninguno', 'Flequillo', 'Bob', 'Largo'],
        lblGlasses: 'Gafas',
        lblEarrings: 'Aretes',
        accOn: 'ON',
        accOff: 'OFF',
        shootTipTitle: 'Tip de Captura',
        shootTipBody: 'Frontal + buena iluminaciÃ³n + rostro grande en cuadro mejora el resultado.',
        hintUpload: 'Sube una foto o activa la cÃ¡mara.',
        cameraPermission: 'Debes permitir la cÃ¡mara para usar esta funciÃ³n.'
      },
      fr: {
        htmlLang: 'fr',
        docTitle: 'Simulateur BeautÃ© IA â€” Curseur Before/After',
        docDesc: 'Warp yeux/nez/lÃ¨vres/contour avec contouring, highlight, eyeliner, lÃ¨vres, blush et coiffures.',
        appTitle: 'Simulateur BeautÃ© IA',
        appSubtitle: 'â€” Plus marquÃ© / Glisser Before-After',
        topSub: 'âœ… Traitement local navigateur (sans upload serveur) Â· âœ… Overlay cheveux + contour/highlight renforcÃ©s Â· âœ… Simulation de rÃ©fÃ©rence',
        langLabel: 'Langue',
        btnCamera: 'Utiliser la CamÃ©ra',
        btnUpload: 'Importer une Photo',
        btnSave: 'Enregistrer lâ€™image',
        btnReset: 'RÃ©initialiser',
        previewTitle: 'ğŸª AperÃ§u',
        pillCompare: 'Glissez pour comparer Before/After',
        pillDepth: 'Pincement du contour + highlight pour effet 2.5D',
        pillHair: 'Overlay cheveux (frange / carrÃ© / long)',
        presetNatural: 'PrÃ©rÃ©glage : Naturel',
        presetDramatic: 'PrÃ©rÃ©glage : Dramatique',
        presetGlow: 'PrÃ©rÃ©glage : Glow',
        tagBefore: 'AVANT',
        tagAfter: 'APRÃˆS',
        tipBadge: 'Astuce',
        tipText: 'Montez â€œPuissanceâ€ Ã  60~80 et changez â€œStyle de cheveuxâ€ pour un effet net.',
        lblMirror: 'Miroir',
        lblLandmarks: 'RepÃ¨res',
        lblHQ: 'Haute QualitÃ©',
        warnTitle: 'Avertissement',
        warnBody: 'Simulateur Ã  but ludique/rÃ©fÃ©rence. Le rÃ©sultat rÃ©el peut diffÃ©rer.',
        controlsTitle: 'ğŸ›ï¸ ContrÃ´les RenforcÃ©s',
        controlsHint: 'Cette version accentue les rÃ©glages pour des changements plus visibles.',
        controlNames: ['Puissance Globale', 'Taille des Yeux', 'Ã‰cart des Yeux', 'Largeur du Nez', 'Nez Plus Haut', 'Volume des LÃ¨vres', 'MÃ¢choire/Contour', 'Lissage de la Peau', 'Contour (Ombres)', 'Blush', 'Eyeliner', 'Couleur des LÃ¨vres', 'Gloss LÃ¨vres', 'Style de Cheveux', 'Couleur des Cheveux', 'Accessoires'],
        controlDescs: ['Gain maÃ®tre de tous les effets', 'Agrandir/rÃ©duire les yeux', 'DÃ©placer les yeux dedans/dehors', 'Warp horizontal du nez', 'Highlight de lâ€™arÃªte + ombre latÃ©rale', 'Agrandir/rÃ©duire les lÃ¨vres', 'Pincer joues/mÃ¢choire vers le centre', 'Lissage + tonalitÃ© du visage', 'Ombres pommettes/mÃ¢choire/nez', 'Couleur des joues', 'Accent du trait supÃ©rieur', 'Couleur des lÃ¨vres', 'Brillance 2.5D', 'Overlay basÃ© sur contour visage/front', 'Couleur de lâ€™overlay cheveux', 'Accessoires basÃ©s yeux/mÃ¢choire'],
        hairOptions: ['Aucun', 'Frange', 'CarrÃ©', 'Long'],
        lblGlasses: 'Lunettes',
        lblEarrings: 'Boucles',
        accOn: 'ON',
        accOff: 'OFF',
        shootTipTitle: 'Conseil de Prise',
        shootTipBody: 'Face camÃ©ra + lumiÃ¨re vive + visage bien cadrÃ© donne un rendu plus naturel.',
        hintUpload: 'Importez une photo ou activez la camÃ©ra.',
        cameraPermission: 'Lâ€™autorisation camÃ©ra est nÃ©cessaire.'
      },
      de: {
        htmlLang: 'de',
        docTitle: 'AI Beauty Simulator â€” Before/After Slider',
        docDesc: 'Augen/Nase/Lippen/Kontur-Warp mit Contour, Highlight, Eyeliner, Lipcolor, Blush und Haar-Overlay.',
        appTitle: 'AI Beauty Simulator',
        appSubtitle: 'â€” Deutlicher / Before-After Ziehen',
        topSub: 'âœ… Nur im Browser (kein Server-Upload) Â· âœ… Haar-Overlay + stÃ¤rkere Kontur/Highlights Â· âœ… Referenz-Simulation',
        langLabel: 'Sprache',
        btnCamera: 'Kamera nutzen',
        btnUpload: 'Foto hochladen',
        btnSave: 'Bild speichern',
        btnReset: 'ZurÃ¼cksetzen',
        previewTitle: 'ğŸª Vorschau',
        pillCompare: 'Slider ziehen fÃ¼r Before/After',
        pillDepth: 'Kontur-Pinch + Highlight fÃ¼r 2.5D-Effekt',
        pillHair: 'Haar-Overlay (Pony / Bob / Lang)',
        presetNatural: 'Preset: NatÃ¼rlich',
        presetDramatic: 'Preset: Dramatisch',
        presetGlow: 'Preset: Glow',
        tagBefore: 'VORHER',
        tagAfter: 'NACHHER',
        tipBadge: 'Tipp',
        tipText: 'â€StÃ¤rkeâ€œ auf 60~80 erhÃ¶hen und â€Frisurâ€œ wechseln fÃ¼r klarere VerÃ¤nderung.',
        lblMirror: 'Spiegeln',
        lblLandmarks: 'Landmarks',
        lblHQ: 'Hohe QualitÃ¤t',
        warnTitle: 'Hinweis',
        warnBody: 'Dieser Simulator dient nur zur Unterhaltung/Referenz. Reale Ergebnisse kÃ¶nnen abweichen.',
        controlsTitle: 'ğŸ›ï¸ Deutliche Steuerung',
        controlsHint: 'Diese Version verstÃ¤rkt Standardwerte fÃ¼r sichtbare Effekte.',
        controlNames: ['GesamtstÃ¤rke', 'AugengrÃ¶ÃŸe', 'Augenabstand', 'Nasenbreite', 'Nase hÃ¶her wirken', 'Lippenvolumen', 'Kiefer/Kontur', 'Hautkorrektur', 'Kontur (Schatten)', 'Rouge', 'Eyeliner', 'Lippenfarbe', 'Lip Gloss', 'Frisur', 'Haarfarbe', 'Accessoires'],
        controlDescs: ['Master-Gain aller Effekte', 'Augen vergrÃ¶ÃŸern/verkleinern', 'Augen nach innen/auÃŸen verschieben', 'Horizontaler Nasen-Warp', 'NasenrÃ¼cken-Highlight + Seitenschatten', 'Lippen vergrÃ¶ÃŸern/verkleinern', 'Wangen/Kiefer zur Mitte pinchen', 'GlÃ¤ttung + Hautton', 'Schatten an Wange/Kiefer/Nase', 'Wangenfarbe', 'Oberes Lid stÃ¤rker betonen', 'Farbe der Lippen', 'Lippenglanz fÃ¼r 2.5D', 'Overlay anhand Gesichtsform/Stirn', 'Farbe des Haar-Overlays', 'Overlay-Accessoires nach Augen/Kiefer'],
        hairOptions: ['Keins', 'Pony', 'Bob', 'Lang'],
        lblGlasses: 'Brille',
        lblEarrings: 'Ohrringe',
        accOn: 'ON',
        accOff: 'OFF',
        shootTipTitle: 'Aufnahme-Tipp',
        shootTipBody: 'Frontal + helles Licht + groÃŸes Gesicht im Bild verbessert das Ergebnis.',
        hintUpload: 'Foto hochladen oder Kamera einschalten.',
        cameraPermission: 'Kameraberechtigung ist erforderlich.'
      }
    };

    function tr(){
      return I18N[currentLang] || I18N.ko;
    }

    // FaceMesh init
    const faceMesh = new FaceMesh({
      locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`
    });
    faceMesh.setOptions({
      maxNumFaces: 1,
      refineLandmarks: true,
      minDetectionConfidence: 0.6,
      minTrackingConfidence: 0.6
    });
    faceMesh.onResults(onResults);

    // ----- Slider UI (Before/After split) -----
    function updateSplitUI(){
      const rect = stage.getBoundingClientRect();
      const x = rect.width * splitX;
      divider.style.left = `${x - 1.5}px`;
      handle.style.left = `${x}px`;
    }
    updateSplitUI();
    window.addEventListener('resize', ()=>{
      updateSplitUI();
      if(!usingCamera && lastFrameCanvas) renderAll();
    });

    function isMobileViewport(){
      return window.matchMedia('(max-width: 900px)').matches;
    }

    function frameIntervalMs(){
      if(!usingCamera) return 0;
      if(isMobileViewport()) return chkHQ.checked ? 95 : 150;
      return chkHQ.checked ? 36 : 68;
    }

    function applyLanguage(lang){
      if(!I18N[lang]) lang = 'ko';
      currentLang = lang;
      const text = tr();
      document.documentElement.lang = text.htmlLang;
      document.title = text.docTitle;
      const metaDesc = document.querySelector('meta[name="description"]');
      if(metaDesc) metaDesc.setAttribute('content', text.docDesc);

      $('appTitle').textContent = text.appTitle;
      $('appSubtitle').textContent = text.appSubtitle;
      $('topSub').textContent = text.topSub;
      $('lblLang').textContent = text.langLabel;
      btnUseCamera.textContent = text.btnCamera;
      $('labelUpload').textContent = text.btnUpload;
      btnSave.textContent = text.btnSave;
      btnReset.textContent = text.btnReset;
      $('previewTitle').textContent = text.previewTitle;
      $('pillCompare').textContent = text.pillCompare;
      $('pillDepth').textContent = text.pillDepth;
      $('pillHair').textContent = text.pillHair;
      btnPresetNatural.textContent = text.presetNatural;
      btnPresetDramatic.textContent = text.presetDramatic;
      btnPresetGlow.textContent = text.presetGlow;
      $('tagBefore').textContent = text.tagBefore;
      $('tagAfter').textContent = text.tagAfter;
      $('tipBadge').textContent = text.tipBadge;
      $('tipText').innerHTML = text.tipText;
      $('lblMirror').textContent = text.lblMirror;
      $('lblLandmarks').textContent = text.lblLandmarks;
      $('lblHQ').textContent = text.lblHQ;
      $('warnTitle').textContent = text.warnTitle;
      $('warnBody').textContent = text.warnBody;
      $('controlsTitle').textContent = text.controlsTitle;
      $('controlsHint').textContent = text.controlsHint;
      $('lblGlasses').textContent = text.lblGlasses;
      $('lblEarrings').textContent = text.lblEarrings;
      $('shootTipTitle').textContent = text.shootTipTitle;
      $('shootTipBody').textContent = text.shootTipBody;

      for(let i=0;i<controlNameEls.length;i++){
        if(text.controlNames[i]) controlNameEls[i].textContent = text.controlNames[i];
      }
      for(let i=0;i<controlDescEls.length;i++){
        if(text.controlDescs[i]) controlDescEls[i].textContent = text.controlDescs[i];
      }

      const hairOptions = hairStyle.querySelectorAll('option');
      text.hairOptions.forEach((name, idx)=>{
        if(hairOptions[idx]) hairOptions[idx].textContent = name;
      });

      setValLabels();
      if(!lastFrameCanvas){
        vctx.fillStyle = "rgb(9,12,26)";
        vctx.fillRect(0,0,view.width,view.height);
        drawHint(vctx, text.hintUpload);
      }
    }

    function detectLanguage(){
      const nav = (navigator.language || 'ko').toLowerCase();
      if(nav.startsWith('ko')) return 'ko';
      if(nav.startsWith('ja')) return 'ja';
      if(nav.startsWith('es')) return 'es';
      if(nav.startsWith('fr')) return 'fr';
      if(nav.startsWith('de')) return 'de';
      if(nav.startsWith('en')) return 'en';
      return 'en';
    }

    function pointerToSplit(e){
      const rect = stage.getBoundingClientRect();
      const clientX = (e.touches && e.touches[0]) ? e.touches[0].clientX : e.clientX;
      let x = (clientX - rect.left) / rect.width;
      x = Math.max(0.02, Math.min(0.98, x));
      splitX = x;
      updateSplitUI();
      composite();
    }

    stage.addEventListener('pointerdown', (e)=>{ dragging = true; stage.setPointerCapture(e.pointerId); pointerToSplit(e); });
    stage.addEventListener('pointermove', (e)=>{ if(dragging) pointerToSplit(e); });
    stage.addEventListener('pointerup', ()=> dragging = false);
    stage.addEventListener('pointercancel', ()=> dragging = false);

    stage.addEventListener('touchstart', (e)=>{ dragging = true; pointerToSplit(e); }, {passive:true});
    stage.addEventListener('touchmove', (e)=>{ if(dragging) pointerToSplit(e); }, {passive:true});
    stage.addEventListener('touchend', ()=> dragging = false);
    langSelect.addEventListener('change', ()=> applyLanguage(langSelect.value));

    // ----- UI bindings -----
    const inputs = [
      chkMirror, chkLandmarks, chkHQ,
      power, eye, eyeSpace, noseW, noseH, lip, slim,
      skin, contour, blush, liner, gloss,
      lipColor, hairStyle, hairColor,
      glasses, earrings
    ];
    inputs.forEach(el=>{
      el.addEventListener('input', ()=>{ setValLabels(); renderAll(); });
      el.addEventListener('change', ()=>{ setValLabels(); renderAll(); });
    });

    btnPresetNatural.addEventListener('click', ()=>{
      applyPreset('natural');
      renderAll();
    });
    btnPresetDramatic.addEventListener('click', ()=>{
      applyPreset('dramatic');
      renderAll();
    });
    btnPresetGlow.addEventListener('click', ()=>{
      applyPreset('glow');
      renderAll();
    });

    btnUseCamera.addEventListener('click', async ()=>{
      if(usingCamera) return;
      usingCamera = true;
      await startCamera();
    });

    file.addEventListener('change', async (e)=>{
      const f = e.target.files?.[0];
      if(!f) return;

      await stopCamera();
      usingCamera = false;

      const url = URL.createObjectURL(f);
      const img = new Image();
      img.onload = async ()=>{
        drawContainToCanvas(img, sctx, src);
        await faceMesh.send({image: src});
        URL.revokeObjectURL(url);
      };
      img.src = url;
    });

    btnSave.addEventListener('click', ()=>{
      // save the composite view canvas
      const a = document.createElement('a');
      a.href = view.toDataURL('image/png');
      a.download = 'beauty-before-after.png';
      document.body.appendChild(a);
      a.click();
      a.remove();
    });

    btnReset.addEventListener('click', async ()=>{
      applyPreset('dramatic'); // keep fun default
      lastLandmarks = null;
      lastFrameCanvas = null;

      if(usingCamera) await stopCamera();
      usingCamera = false;

      // placeholder
      vctx.setTransform(1,0,0,1,0,0);
      vctx.fillStyle = "rgb(9,12,26)";
      vctx.fillRect(0,0,view.width,view.height);
      drawHint(vctx, tr().hintUpload);
      setActions(false);
    });

    function setActions(on){
      btnSave.disabled = !on;
      btnPresetNatural.disabled = !on;
      btnPresetDramatic.disabled = !on;
      btnPresetGlow.disabled = !on;
    }

    function setValLabels(){
      const text = tr();
      vPower.textContent = power.value;
      vEye.textContent = eye.value;
      vEyeSpace.textContent = eyeSpace.value;
      vNoseW.textContent = noseW.value;
      vNoseH.textContent = noseH.value;
      vLip.textContent = lip.value;
      vSlim.textContent = slim.value;
      vSkin.textContent = skin.value;
      vContour.textContent = contour.value;
      vBlush.textContent = blush.value;
      vLiner.textContent = liner.value;
      vGloss.textContent = gloss.value;
      vLipColor.textContent = lipColor.value;
      vHairStyle.textContent = hairStyle.options[hairStyle.selectedIndex].textContent;
      vHairColor.textContent = hairColor.value;
      vAcc.textContent = (glasses.checked || earrings.checked) ? text.accOn : text.accOff;
    }

    function applyPreset(name){
      // you asked â€œë” í‹° ë‚˜ê²Œâ€, so defaults are already strong.
      if(name === 'natural'){
        power.value = 45;
        eye.value = 12; eyeSpace.value = 4;
        noseW.value = -8; noseH.value = 28;
        lip.value = 10; slim.value = 22;
        skin.value = 28; contour.value = 22; blush.value = 18; liner.value = 28; gloss.value = 22;
        hairStyle.value = "bangs";
        glasses.checked = false; earrings.checked = true;
      }
      if(name === 'dramatic'){
        power.value = 75;
        eye.value = 30; eyeSpace.value = 8;
        noseW.value = -14; noseH.value = 55;
        lip.value = 22; slim.value = 45;
        skin.value = 38; contour.value = 40; blush.value = 32; liner.value = 55; gloss.value = 40;
        hairStyle.value = "bob";
        glasses.checked = true; earrings.checked = true;
      }
      if(name === 'glow'){
        power.value = 70;
        eye.value = 22; eyeSpace.value = 6;
        noseW.value = -12; noseH.value = 65;
        lip.value = 18; slim.value = 35;
        skin.value = 50; contour.value = 28; blush.value = 26; liner.value = 38; gloss.value = 70;
        hairStyle.value = "long";
        glasses.checked = false; earrings.checked = true;
      }
      setValLabels();
    }

    if(isMobileViewport()) chkHQ.checked = false;
    const initialLang = detectLanguage();
    langSelect.value = initialLang;
    applyLanguage(initialLang);

    // initial preset
    applyPreset('dramatic');
    setActions(false);

    // placeholder
    vctx.fillStyle = "rgb(9,12,26)";
    vctx.fillRect(0,0,view.width,view.height);
    drawHint(vctx, tr().hintUpload);

    // ----- Camera -----
    async function startCamera(){
      try{
        const stream = await navigator.mediaDevices.getUserMedia({ video:{ facingMode:"user" }, audio:false });
        video.srcObject = stream;
        await video.play();

        camera = new Camera(video, {
          onFrame: async ()=>{
            const now = performance.now();
            if(now - lastProcessAt < frameIntervalMs()) return;
            lastProcessAt = now;
            drawContainToCanvas(video, sctx, src);
            await faceMesh.send({image: src});
          },
          width: 1280,
          height: 960
        });
        camera.start();
      }catch(err){
        console.error(err);
        alert(tr().cameraPermission);
        usingCamera = false;
      }
    }

    async function stopCamera(){
      if(camera){
        try{ camera.stop(); }catch{}
        camera = null;
      }
      const stream = video.srcObject;
      if(stream && stream.getTracks) stream.getTracks().forEach(t=>t.stop());
      video.srcObject = null;
    }

    // ----- FaceMesh results -----
    function onResults(results){
      lastLandmarks = results.multiFaceLandmarks?.[0] || null;
      lastFrameCanvas = src;
      setActions(true);
      renderAll();
    }

    // ----- Render pipeline -----
    function renderAll(){
      if(!lastFrameCanvas){
        vctx.setTransform(1,0,0,1,0,0);
        vctx.fillStyle = "rgb(9,12,26)";
        vctx.fillRect(0,0,view.width,view.height);
        drawHint(vctx, tr().hintUpload);
        return;
      }
      renderBefore();
      renderAfter();
      composite();
    }

    function renderBefore(){
      bctx.setTransform(1,0,0,1,0,0);
      bctx.clearRect(0,0,beforeC.width,beforeC.height);

      if(chkMirror.checked){
        bctx.translate(beforeC.width, 0);
        bctx.scale(-1, 1);
      }
      bctx.drawImage(lastFrameCanvas, 0, 0, beforeC.width, beforeC.height);

      if(chkLandmarks.checked && lastLandmarks){
        drawLandmarks(lastLandmarks, bctx);
      }
    }

    function renderAfter(){
      actx.setTransform(1,0,0,1,0,0);
      actx.clearRect(0,0,afterC.width,afterC.height);

      if(chkMirror.checked){
        actx.translate(afterC.width, 0);
        actx.scale(-1, 1);
      }
      actx.drawImage(lastFrameCanvas, 0, 0, afterC.width, afterC.height);

      if(!lastLandmarks){
        return;
      }

      // master power
      const PWR = Number(power.value) / 100; // 0..1
      const HQ = chkHQ.checked;

      const lm = lastLandmarks;
      const W = afterC.width, H = afterC.height;
      const Pt = (i)=>({x: lm[i].x * W, y: lm[i].y * H});

      // anchors
      const leftEyeC  = avg([Pt(33), Pt(133), Pt(159), Pt(145)]);
      const rightEyeC = avg([Pt(362), Pt(263), Pt(386), Pt(374)]);
      const mouthC    = avg([Pt(13), Pt(14), Pt(78), Pt(308)]);
      const noseTip   = Pt(1);
      const noseBridge= avg([Pt(6), Pt(168), Pt(197)]);
      const chinTip   = Pt(152);

      const leftCheek  = avg([Pt(234), Pt(93), Pt(132)]);
      const rightCheek = avg([Pt(454), Pt(323), Pt(361)]);
      const leftJawMid  = Pt(172);
      const rightJawMid = Pt(397);

      // face oval mask
      const faceOvalIdx = [10,338,297,332,284,251,389,356,454,323,361,288,397,365,379,378,400,377,152,148,176,149,150,136,172,58,132,93,234,127,162,21,54,103,67,109];
      const faceOval = faceOvalIdx.map(Pt);

      // parameters (scaled by power)
      const eyeScale = (Number(eye.value)/100) * (0.55 + 0.75*PWR);
      const eyeSpaceV= (Number(eyeSpace.value)/100) * (0.55 + 0.75*PWR);

      const noseWV = (Number(noseW.value)/100) * (0.55 + 0.85*PWR);
      const noseHV = (Number(noseH.value)/100) * (0.45 + 0.85*PWR);

      const lipScale = (Number(lip.value)/100) * (0.55 + 0.80*PWR);
      const slimV = (Number(slim.value)/100) * (0.55 + 0.85*PWR);

      const skinV = (Number(skin.value)/100) * (0.55 + 0.85*PWR);
      const contourV = (Number(contour.value)/100) * (0.55 + 0.85*PWR);
      const blushV = (Number(blush.value)/100) * (0.55 + 0.85*PWR);
      const linerV = (Number(liner.value)/100) * (0.55 + 0.85*PWR);
      const glossV = (Number(gloss.value)/100) * (0.55 + 0.85*PWR);

      // 1) skin (stronger)
      if(skinV > 0.001){
        applySkin(actx, faceOval, skinV, HQ);
      }

      // 2) Slim pinch (the most â€œí‹° ë‚¨â€)
      if(slimV > 0.001){
        softPinch(actx, leftCheek,   360, 520, slimV*0.55, +1, HQ);
        softPinch(actx, rightCheek,  360, 520, slimV*0.55, -1, HQ);
        softPinch(actx, leftJawMid,  330, 480, slimV*0.65, +1, HQ);
        softPinch(actx, rightJawMid, 330, 480, slimV*0.65, -1, HQ);
        // extra â€œV-lineâ€ feel near chin
        softPinch(actx, chinTip, 420, 440, slimV*0.30, 0, HQ); // 0 => symmetrical inward
      }

      // 3) eyes (spacing + scaling)
      if(Math.abs(eyeSpaceV) > 0.001){
        shiftRegion(actx, leftEyeC,  280, 200, -eyeSpaceV*100);
        shiftRegion(actx, rightEyeC, 280, 200, +eyeSpaceV*100);
      }
      if(Math.abs(eyeScale) > 0.001){
        regionScale(actx, leftEyeC,  280, 200, 1 + eyeScale, 1 + eyeScale*0.85);
        regionScale(actx, rightEyeC, 280, 200, 1 + eyeScale, 1 + eyeScale*0.85);
      }

      // 4) nose width (narrow/widen)
      if(Math.abs(noseWV) > 0.001){
        regionScale(actx, noseTip,  360, 520, 1 + noseWV, 1);
      }

      // 5) lips
      if(Math.abs(lipScale) > 0.001){
        regionScale(actx, mouthC, 560, 360, 1 + lipScale, 1 + lipScale*0.70);
      }

      // 6) Contour + highlight (make it â€œ3D-ishâ€)
      if(contourV > 0.001 || noseHV > 0.001){
        applyContourHighlight(actx, {
          faceOval, noseBridge, noseTip,
          leftCheek, rightCheek, chinTip,
          contourV, noseHV, HQ
        });
      }

      // 7) blush
      if(blushV > 0.001){
        applyBlush(actx, leftCheek, rightCheek, blushV, HQ);
      }

      // 8) eyeliner
      if(linerV > 0.001){
        applyEyeliner(actx, lm, linerV);
      }

      // 9) lips color + gloss
      applyLips(actx, lm, lipColor.value, 0.18 + 0.62*Math.max(0, lipScale+0.15), glossV, HQ);

      // 10) hair overlay (THIS makes it super obvious)
      if(hairStyle.value !== 'none'){
        drawHairOverlay(actx, lm, hairStyle.value, hairColor.value, HQ);
      }

      // 11) accessories
      if(glasses.checked) drawGlasses(actx, leftEyeC, rightEyeC);
      if(earrings.checked){
        const leftJaw = Pt(234);
        const rightJaw = Pt(454);
        drawEarrings(actx, leftJaw, rightJaw, HQ);
      }

      if(chkLandmarks.checked) drawLandmarks(lm, actx);
    }

    // composite split view onto main canvas
    function composite(){
      const W = view.width, H = view.height;
      vctx.setTransform(1,0,0,1,0,0);
      vctx.clearRect(0,0,W,H);

      // Draw AFTER full, then clip BEFORE on left side (so handle shows transition)
      vctx.drawImage(afterC, 0, 0);

      const cut = Math.floor(W * splitX);
      vctx.save();
      vctx.beginPath();
      vctx.rect(0,0,cut,H);
      vctx.clip();
      vctx.drawImage(beforeC, 0, 0);
      vctx.restore();
    }

    // ----- Helpers / Effects -----
    function drawHint(ctx, text){
      const line2 = tr().shootTipBody;
      ctx.save();
      ctx.fillStyle = "rgb(9,12,26)";
      ctx.fillRect(0,0,view.width,view.height);
      ctx.fillStyle = "rgba(255,255,255,.90)";
      ctx.font = "900 28px ui-sans-serif";
      ctx.fillText(text, 48, 120);
      ctx.fillStyle = "rgba(255,255,255,.55)";
      ctx.font = "700 16px ui-sans-serif";
      ctx.fillText(line2, 48, 150);
      ctx.restore();
    }

    function drawContainToCanvas(media, ctx, canvas){
      const cw = canvas.width, ch = canvas.height;
      const mw = media.videoWidth || media.naturalWidth || media.width;
      const mh = media.videoHeight || media.naturalHeight || media.height;
      if(!mw || !mh) return;

      const scale = Math.min(cw / mw, ch / mh);
      const dw = mw * scale;
      const dh = mh * scale;
      const dx = (cw - dw) / 2;
      const dy = (ch - dh) / 2;
      ctx.setTransform(1,0,0,1,0,0);
      ctx.clearRect(0,0,cw,ch);
      ctx.drawImage(media, dx, dy, dw, dh);
    }

    function avg(points){
      let x=0,y=0;
      for(const p of points){ x+=p.x; y+=p.y; }
      return {x:x/points.length, y:y/points.length};
    }

    function drawLandmarks(lm, ctx){
      const W = ctx.canvas.width, H = ctx.canvas.height;
      ctx.save();
      ctx.globalAlpha = 0.75;
      ctx.fillStyle = "rgba(255,211,110,.9)";
      for(let i=0;i<lm.length;i++){
        const x = lm[i].x*W, y = lm[i].y*H;
        ctx.fillRect(x-1, y-1, 2, 2);
      }
      ctx.restore();
    }

    function polygonClip(ctx, poly){
      ctx.beginPath();
      ctx.moveTo(poly[0].x, poly[0].y);
      for(let i=1;i<poly.length;i++) ctx.lineTo(poly[i].x, poly[i].y);
      ctx.closePath();
      ctx.clip();
    }
    function polygonFill(ctx, poly){
      ctx.beginPath();
      ctx.moveTo(poly[0].x, poly[0].y);
      for(let i=1;i<poly.length;i++) ctx.lineTo(poly[i].x, poly[i].y);
      ctx.closePath();
      ctx.fill();
    }

    function regionScale(ctx, center, w, h, sx, sy){
      const x = Math.round(center.x - w/2);
      const y = Math.round(center.y - h/2);
      const tw = Math.round(w);
      const th = Math.round(h);

      const tmp = document.createElement('canvas');
      tmp.width = tw; tmp.height = th;
      tmp.getContext('2d').drawImage(ctx.canvas, x, y, tw, th, 0, 0, tw, th);

      ctx.save();
      ctx.beginPath();
      ctx.ellipse(center.x, center.y, w*0.49, h*0.49, 0, 0, Math.PI*2);
      ctx.clip();

      const dw = tw*sx, dh = th*sy;
      ctx.drawImage(tmp, center.x - dw/2, center.y - dh/2, dw, dh);

      ctx.restore();
    }

    function shiftRegion(ctx, center, w, h, dx){
      const x = Math.round(center.x - w/2);
      const y = Math.round(center.y - h/2);
      const tw = Math.round(w);
      const th = Math.round(h);

      const tmp = document.createElement('canvas');
      tmp.width = tw; tmp.height = th;
      tmp.getContext('2d').drawImage(ctx.canvas, x, y, tw, th, 0, 0, tw, th);

      ctx.save();
      ctx.beginPath();
      ctx.ellipse(center.x, center.y, w*0.49, h*0.49, 0, 0, Math.PI*2);
      ctx.clip();

      ctx.drawImage(tmp, x + dx, y, tw, th);
      ctx.restore();
    }

    // softPinch: sliced warp; dir=+1 inward right, -1 inward left, 0 symmetric inward to center
    function softPinch(ctx, center, w, h, strength, dir, HQ){
      const x = Math.round(center.x - w/2);
      const y = Math.round(center.y - h/2);
      const tw = Math.round(w);
      const th = Math.round(h);

      const tmp = document.createElement('canvas');
      tmp.width = tw; tmp.height = th;
      tmp.getContext('2d').drawImage(ctx.canvas, x, y, tw, th, 0, 0, tw, th);

      const slices = HQ ? 38 : 28;
      const sliceW = Math.max(2, Math.floor(tw / slices));
      const maxShift = strength * 0.22 * tw;

      ctx.save();
      ctx.beginPath();
      ctx.ellipse(center.x, center.y, w*0.49, h*0.49, 0, 0, Math.PI*2);
      ctx.clip();

      for(let i=0;i<slices;i++){
        const sx = i*sliceW;
        const sw = (i===slices-1) ? (tw - sx) : sliceW;

        const t = i/(slices-1); // 0..1 across region

        let edge;
        if(dir === +1) edge = (1 - t);          // outer edge on left
        else if(dir === -1) edge = t;           // outer edge on right
        else edge = Math.abs(t - 0.5) * 2;      // both edges
        const wgt = Math.pow(edge, 1.55);

        let shift = maxShift * wgt;
        if(dir === +1) shift = +shift;
        else if(dir === -1) shift = -shift;
        else shift = (t<0.5) ? +shift : -shift; // symmetric toward center

        ctx.drawImage(tmp, sx, 0, sw, th, x + sx + shift, y, sw, th);
      }
      ctx.restore();
    }

    function applySkin(ctx, facePoly, amount, HQ){
      const passes = HQ ? Math.round(3 + amount*7) : Math.round(2 + amount*4);
      const alpha = HQ ? (0.05 + amount*0.11) : (0.045 + amount*0.08);

      ctx.save();
      polygonClip(ctx, facePoly);

      ctx.globalAlpha = alpha;
      for(let i=0;i<passes;i++){
        const s = 1 + (i+1) * (HQ ? 0.0035 : 0.0023) * amount;
        ctx.save();
        ctx.translate(ctx.canvas.width/2, ctx.canvas.height/2);
        ctx.scale(s, s);
        ctx.translate(-ctx.canvas.width/2, -ctx.canvas.height/2);
        ctx.drawImage(ctx.canvas, 0, 0);
        ctx.restore();
      }

      // tone lift + tiny highlight
      ctx.globalAlpha = 0.06 + amount*0.16;
      ctx.fillStyle = "rgba(255,235,240,0.35)";
      ctx.fillRect(0,0,ctx.canvas.width, ctx.canvas.height);

      ctx.globalAlpha = 0.05 + amount*0.10;
      ctx.fillStyle = "rgba(255,255,255,0.20)";
      ctx.fillRect(0,0,ctx.canvas.width, ctx.canvas.height);

      ctx.restore();
      ctx.globalAlpha = 1;
    }

    function radialGlow(ctx, x, y, r, color){
      const g = ctx.createRadialGradient(x,y, 0, x,y, r);
      g.addColorStop(0, color);
      g.addColorStop(1, "rgba(0,0,0,0)");
      ctx.fillStyle = g;
      ctx.beginPath();
      ctx.arc(x,y,r,0,Math.PI*2);
      ctx.fill();
    }

    function applyContourHighlight(ctx, cfg){
      const {faceOval, noseBridge, noseTip, leftCheek, rightCheek, chinTip, contourV, noseHV, HQ} = cfg;

      ctx.save();
      polygonClip(ctx, faceOval);

      // contour (stronger)
      if(contourV > 0.001){
        const a = contourV * (HQ ? 0.30 : 0.22);
        ctx.globalAlpha = a;

        radialGlow(ctx, leftCheek.x - 160, leftCheek.y + 140, HQ ? 320 : 260, "rgba(35,15,20,0.55)");
        radialGlow(ctx, rightCheek.x + 160, rightCheek.y + 140, HQ ? 320 : 260, "rgba(35,15,20,0.55)");

        radialGlow(ctx, leftCheek.x - 70, leftCheek.y + 40, HQ ? 260 : 220, "rgba(45,18,22,0.45)");
        radialGlow(ctx, rightCheek.x + 70, rightCheek.y + 40, HQ ? 260 : 220, "rgba(45,18,22,0.45)");

        radialGlow(ctx, chinTip.x, chinTip.y + 70, HQ ? 280 : 240, "rgba(40,18,22,0.55)");
        ctx.globalAlpha = 1;
      }

      // nose height (highlight + side shading)
      if(noseHV > 0.001){
        const a = noseHV * (HQ ? 0.50 : 0.36);
        ctx.globalAlpha = a;

        const g = ctx.createLinearGradient(noseBridge.x, noseBridge.y - 140, noseTip.x, noseTip.y + 160);
        g.addColorStop(0, "rgba(255,255,255,0.00)");
        g.addColorStop(0.35, "rgba(255,255,255,0.55)");
        g.addColorStop(0.65, "rgba(255,255,255,0.28)");
        g.addColorStop(1, "rgba(255,255,255,0.00)");
        ctx.fillStyle = g;
        roundRectFill(ctx, noseBridge.x - 18, noseBridge.y - 110, 36, 280, 18);

        // side shadows
        ctx.globalAlpha = a*0.62;
        radialGlow(ctx, noseTip.x - 48, noseTip.y + 22, HQ ? 150 : 130, "rgba(35,14,18,0.55)");
        radialGlow(ctx, noseTip.x + 48, noseTip.y + 22, HQ ? 150 : 130, "rgba(35,14,18,0.55)");

        // tip highlight
        ctx.globalAlpha = a*0.62;
        radialGlow(ctx, noseTip.x, noseTip.y + 12, HQ ? 105 : 90, "rgba(255,255,255,0.35)");

        ctx.globalAlpha = 1;
      }

      // cheekbone highlight (2.5D pop)
      ctx.globalAlpha = (HQ ? 0.10 : 0.08) * (0.6 + contourV);
      radialGlow(ctx, leftCheek.x - 20, leftCheek.y - 10, HQ ? 230 : 190, "rgba(255,255,255,0.20)");
      radialGlow(ctx, rightCheek.x + 20, rightCheek.y - 10, HQ ? 230 : 190, "rgba(255,255,255,0.20)");
      ctx.globalAlpha = 1;

      ctx.restore();
    }

    function applyBlush(ctx, leftCheek, rightCheek, amount, HQ){
      const a = amount * (HQ ? 0.38 : 0.28);
      ctx.save();
      ctx.globalAlpha = a;
      radialGlow(ctx, leftCheek.x - 18, leftCheek.y + 30, HQ ? 190 : 160, "rgba(255,80,120,0.55)");
      radialGlow(ctx, rightCheek.x + 18, rightCheek.y + 30, HQ ? 190 : 160, "rgba(255,80,120,0.55)");
      ctx.restore();
    }

    function applyEyeliner(ctx, lm, amount){
      const W = ctx.canvas.width, H = ctx.canvas.height;
      const a = amount; // already 0..1
      if(a <= 0.001) return;

      const P = (i)=>({x: lm[i].x*W, y: lm[i].y*H});
      const leftUpper  = [33, 160, 158, 157, 173, 133];
      const rightUpper = [362, 385, 387, 386, 384, 263];

      ctx.save();
      ctx.globalAlpha = 0.12 + a*0.65;
      ctx.strokeStyle = "rgba(8,8,12,0.95)";
      ctx.lineWidth = 2.2 + a*3.2;
      ctx.lineCap = "round";
      ctx.lineJoin = "round";

      strokePath(leftUpper.map(P));
      strokePath(rightUpper.map(P));

      // wing
      ctx.globalAlpha = 0.10 + a*0.60;
      wing(P(33), P(133), +1);
      wing(P(362), P(263), -1);

      ctx.restore();

      function strokePath(pts){
        ctx.beginPath();
        ctx.moveTo(pts[0].x, pts[0].y);
        for(let i=1;i<pts.length;i++) ctx.lineTo(pts[i].x, pts[i].y);
        ctx.stroke();
      }
      function wing(outer, inner, dir){
        const dx = outer.x - inner.x;
        const dy = outer.y - inner.y;
        const len = Math.hypot(dx,dy) || 1;
        const nx = (dx/len), ny = (dy/len);
        const wx = outer.x + nx*18 + dir*4;
        const wy = outer.y + ny*10 - 6;
        ctx.beginPath();
        ctx.moveTo(outer.x, outer.y);
        ctx.lineTo(wx, wy);
        ctx.stroke();
      }
    }

    function applyLips(ctx, lm, hex, strength, glossAmount, HQ){
      const W = ctx.canvas.width, H = ctx.canvas.height;
      const P = (i)=>({x: lm[i].x*W, y: lm[i].y*H});

      const lipOuter = [61,185,40,39,37,0,267,269,270,409,291,375,321,405,314,17,84,181,91,146];
      const poly = lipOuter.map(P);

      ctx.save();

      // base fill
      ctx.globalAlpha = clamp01(strength);
      ctx.fillStyle = hexToRgba(hex, 0.90);
      polygonFill(ctx, poly);

      // soften edges
      ctx.globalAlpha = (HQ ? 0.16 : 0.12) + 0.20*clamp01(strength);
      ctx.filter = `blur(${HQ ? 1.6 : 1.1}px)`;
      polygonFill(ctx, poly);
      ctx.filter = "none";

      // inner gradient for â€œ3D lipâ€
      ctx.globalAlpha = 0.16 + 0.28*clamp01(strength);
      const m = avg([P(13), P(14), P(78), P(308)]);
      radialGlow(ctx, m.x, m.y + 18, HQ ? 150 : 120, "rgba(255,255,255,0.18)");

      // gloss highlight
      if(glossAmount > 0.001){
        ctx.globalAlpha = glossAmount * (HQ ? 0.45 : 0.34);
        const topC = avg([P(13), P(0), P(267)]);
        radialGlow(ctx, topC.x, topC.y + 10, HQ ? 140 : 110, "rgba(255,255,255,0.38)");
      }

      ctx.restore();
    }

    function clamp01(x){ return Math.max(0, Math.min(1, x)); }
    function hexToRgba(hex, a){
      const h = hex.replace('#','').trim();
      const r = parseInt(h.substring(0,2), 16);
      const g = parseInt(h.substring(2,4), 16);
      const b = parseInt(h.substring(4,6), 16);
      return `rgba(${r},${g},${b},${a})`;
    }
    function roundRectFill(ctx, x, y, w, h, r){
      ctx.beginPath();
      ctx.moveTo(x+r,y);
      ctx.arcTo(x+w,y,x+w,y+h,r);
      ctx.arcTo(x+w,y+h,x,y+h,r);
      ctx.arcTo(x,y+h,x,y,r);
      ctx.arcTo(x,y,x+w,y,r);
      ctx.closePath();
      ctx.fill();
    }

    // ----- Hair overlay (big visual change) -----
    function drawHairOverlay(ctx, lm, style, colorHex, HQ){
      const W = ctx.canvas.width, H = ctx.canvas.height;
      const P = (i)=>({x: lm[i].x*W, y: lm[i].y*H});

      // face oval points
      const faceIdx = [10,338,297,332,284,251,389,356,454,323,361,288,397,365,379,378,400,377,152,148,176,149,150,136,172,58,132,93,234,127,162,21,54,103,67,109];
      const face = faceIdx.map(P);

      // key points
      const forehead = P(10);
      const chin = P(152);
      const leftTemple = P(109);
      const rightTemple = P(338);
      const leftJaw = P(234);
      const rightJaw = P(454);

      // approximate head box
      const faceBox = bounds(face);
      const headTopY = Math.max(0, faceBox.yMin - (faceBox.h * 0.55));
      const headW = faceBox.w * 1.35;
      const headX = faceBox.cx - headW/2;

      ctx.save();

      // shadow behind hair for depth
      ctx.globalAlpha = HQ ? 0.25 : 0.20;
      ctx.filter = `blur(${HQ ? 6 : 4}px)`;
      ctx.fillStyle = "rgba(0,0,0,0.55)";
      ctx.beginPath();
      ctx.ellipse(faceBox.cx, faceBox.yMin + faceBox.h*0.25, headW*0.50, faceBox.h*0.70, 0, 0, Math.PI*2);
      ctx.fill();
      ctx.filter = "none";

      // hair base gradient
      const base = ctx.createLinearGradient(0, headTopY, 0, faceBox.yMax + faceBox.h*0.35);
      base.addColorStop(0, hexToRgba(colorHex, 0.95));
      base.addColorStop(0.6, hexToRgba(colorHex, 0.88));
      base.addColorStop(1, "rgba(0,0,0,0.55)");

      // hair shape depending on style
      ctx.globalAlpha = 0.98;
      ctx.fillStyle = base;

      if(style === 'bangs'){
        // cap + bangs
        hairCap(ctx, headX, headTopY, headW, faceBox.h*0.95, 0.52);
        // bangs: multiple strands across forehead
        bangs(ctx, leftTemple, rightTemple, forehead, faceBox.h*0.20);
      } else if(style === 'bob'){
        // bob: cap + rounded sides down to jaw
        hairCap(ctx, headX, headTopY, headW, faceBox.h*0.95, 0.55);
        bobSides(ctx, leftJaw, rightJaw, chin, faceBox.h*0.15);
      } else if(style === 'long'){
        // long: cap + long drapes
        hairCap(ctx, headX, headTopY, headW, faceBox.h*1.10, 0.58);
        longDrape(ctx, leftTemple, rightTemple, chin, faceBox.h*0.55);
        bangs(ctx, leftTemple, rightTemple, forehead, faceBox.h*0.12); // light bangs for realism
      }

      // hair shine (adds 3D feel)
      ctx.globalAlpha = HQ ? 0.18 : 0.14;
      ctx.filter = `blur(${HQ ? 8 : 6}px)`;
      const shine = ctx.createLinearGradient(faceBox.cx - headW*0.25, headTopY, faceBox.cx + headW*0.15, headTopY + faceBox.h);
      shine.addColorStop(0, "rgba(255,255,255,0.00)");
      shine.addColorStop(0.4, "rgba(255,255,255,0.22)");
      shine.addColorStop(0.8, "rgba(255,255,255,0.02)");
      ctx.fillStyle = shine;
      ctx.beginPath();
      ctx.ellipse(faceBox.cx - headW*0.10, headTopY + faceBox.h*0.35, headW*0.22, faceBox.h*0.45, -0.12, 0, Math.PI*2);
      ctx.fill();
      ctx.filter = "none";

      // clip hair so it doesnâ€™t paint over face too much: subtract face area a little (soft)
      ctx.globalCompositeOperation = "destination-out";
      ctx.globalAlpha = 0.25;
      ctx.filter = `blur(${HQ ? 10 : 7}px)`;
      polygonFill(ctx, face);
      ctx.filter = "none";
      ctx.globalCompositeOperation = "source-over";

      ctx.restore();

      function hairCap(ctx, x, y, w, h, round){
        ctx.beginPath();
        ctx.moveTo(x + w*0.10, y + h*0.35);
        ctx.bezierCurveTo(x + w*0.18, y + h*0.05, x + w*0.82, y + h*0.05, x + w*0.90, y + h*0.35);
        ctx.bezierCurveTo(x + w*0.98, y + h*(0.70+round*0.12), x + w*0.70, y + h*0.95, x + w*0.50, y + h*0.98);
        ctx.bezierCurveTo(x + w*0.30, y + h*0.95, x + w*0.02, y + h*(0.70+round*0.12), x + w*0.10, y + h*0.35);
        ctx.closePath();
        ctx.fill();
      }

      function bangs(ctx, L, R, F, depth){
        const topY = Math.min(L.y, R.y, F.y) + depth*0.10;
        const bottomY = F.y + depth*0.55;
        const leftX = L.x - (R.x-L.x)*0.06;
        const rightX = R.x + (R.x-L.x)*0.06;

        // main bangs mass
        ctx.beginPath();
        ctx.moveTo(leftX, topY);
        ctx.bezierCurveTo(leftX + (rightX-leftX)*0.25, bottomY - depth*0.55, rightX - (rightX-leftX)*0.25, bottomY - depth*0.55, rightX, topY);
        ctx.bezierCurveTo(rightX - (rightX-leftX)*0.10, bottomY + depth*0.15, leftX + (rightX-leftX)*0.10, bottomY + depth*0.15, leftX, topY);
        ctx.closePath();
        ctx.fill();

        // strands (more â€œí‹°â€)
        ctx.save();
        ctx.globalAlpha *= 0.35;
        ctx.strokeStyle = "rgba(0,0,0,0.28)";
        ctx.lineWidth = 2;
        for(let i=0;i<9;i++){
          const t = i/8;
          const x = leftX*(1-t) + rightX*t;
          ctx.beginPath();
          ctx.moveTo(x, topY);
          ctx.quadraticCurveTo(x + (Math.random()*12-6), bottomY, x + (Math.random()*18-9), bottomY + depth*0.12);
          ctx.stroke();
        }
        ctx.restore();
      }

      function bobSides(ctx, LJ, RJ, chin, extra){
        const y1 = Math.min(LJ.y, RJ.y) - extra*0.25;
        const y2 = chin.y + extra*0.10;

        // left side
        ctx.beginPath();
        ctx.moveTo(LJ.x - 60, y1);
        ctx.quadraticCurveTo(LJ.x - 120, (y1+y2)/2, LJ.x - 40, y2);
        ctx.quadraticCurveTo(LJ.x + 10, y2 - 10, LJ.x - 10, y1 + 40);
        ctx.closePath();
        ctx.fill();

        // right side
        ctx.beginPath();
        ctx.moveTo(RJ.x + 60, y1);
        ctx.quadraticCurveTo(RJ.x + 120, (y1+y2)/2, RJ.x + 40, y2);
        ctx.quadraticCurveTo(RJ.x - 10, y2 - 10, RJ.x + 10, y1 + 40);
        ctx.closePath();
        ctx.fill();
      }

      function longDrape(ctx, L, R, chin, len){
        const yTop = Math.min(L.y, R.y) - 30;
        const yBot = chin.y + len;

        // left drape
        ctx.beginPath();
        ctx.moveTo(L.x - 40, yTop);
        ctx.bezierCurveTo(L.x - 200, yTop + len*0.25, L.x - 180, yBot - len*0.15, L.x - 70, yBot);
        ctx.bezierCurveTo(L.x - 20, yBot - 20, L.x + 40, yTop + 80, L.x - 40, yTop);
        ctx.closePath();
        ctx.fill();

        // right drape
        ctx.beginPath();
        ctx.moveTo(R.x + 40, yTop);
        ctx.bezierCurveTo(R.x + 200, yTop + len*0.25, R.x + 180, yBot - len*0.15, R.x + 70, yBot);
        ctx.bezierCurveTo(R.x + 20, yBot - 20, R.x - 40, yTop + 80, R.x + 40, yTop);
        ctx.closePath();
        ctx.fill();
      }

      function bounds(pts){
        let xMin=1e9,yMin=1e9,xMax=-1e9,yMax=-1e9;
        for(const p of pts){
          xMin = Math.min(xMin, p.x);
          yMin = Math.min(yMin, p.y);
          xMax = Math.max(xMax, p.x);
          yMax = Math.max(yMax, p.y);
        }
        const w = xMax-xMin, h=yMax-yMin;
        return {xMin,yMin,xMax,yMax,w,h,cx:(xMin+xMax)/2, cy:(yMin+yMax)/2};
      }
    }

    // ----- Accessories -----
    function drawGlasses(ctx, leftEye, rightEye){
      const dx = rightEye.x - leftEye.x;
      const dy = rightEye.y - leftEye.y;
      const dist = Math.hypot(dx, dy);
      const angle = Math.atan2(dy, dx);

      const frameW = dist * 2.20;
      const frameH = dist * 0.75;
      const bridgeW = dist * 0.22;

      ctx.save();
      ctx.translate((leftEye.x + rightEye.x)/2, (leftEye.y + rightEye.y)/2);
      ctx.rotate(angle);
      ctx.globalAlpha = 0.92;

      const lw = Math.max(2.5, dist*0.05);
      ctx.lineWidth = lw;
      ctx.strokeStyle = "rgba(255,255,255,.86)";
      ctx.fillStyle = "rgba(0,0,0,.12)";

      const lensW = (frameW - bridgeW) / 2;
      const lensH = frameH;

      rr(-frameW/2, -lensH/2, lensW, lensH, lensH*0.28); ctx.fill(); ctx.stroke();
      rr(frameW/2 - lensW, -lensH/2, lensW, lensH, lensH*0.28); ctx.fill(); ctx.stroke();

      ctx.beginPath(); ctx.moveTo(-bridgeW/2, 0); ctx.lineTo(bridgeW/2, 0); ctx.stroke();

      ctx.globalAlpha = 0.78;
      ctx.beginPath();
      ctx.moveTo(-frameW/2, -lensH*0.06); ctx.lineTo(-frameW/2 - dist*0.65, -lensH*0.20);
      ctx.moveTo(frameW/2, -lensH*0.06);  ctx.lineTo(frameW/2 + dist*0.65, -lensH*0.20);
      ctx.stroke();

      ctx.restore();

      function rr(x,y,w,h,r){
        ctx.beginPath();
        ctx.moveTo(x+r,y);
        ctx.arcTo(x+w,y,x+w,y+h,r);
        ctx.arcTo(x+w,y+h,x,y+h,r);
        ctx.arcTo(x,y+h,x,y,r);
        ctx.arcTo(x,y,x+w,y,r);
        ctx.closePath();
      }
    }

    function drawEarrings(ctx, leftJaw, rightJaw, HQ){
      ctx.save();
      ctx.globalAlpha = 0.90;
      const r = ctx.canvas.width * 0.0068;

      const g = ctx.createLinearGradient(0,0,0, ctx.canvas.height);
      g.addColorStop(0, "rgba(255,226,140,.95)");
      g.addColorStop(1, "rgba(255,170,90,.85)");
      ctx.fillStyle = g;
      ctx.strokeStyle = "rgba(255,255,255,.25)";
      ctx.lineWidth = 2;

      drop(leftJaw.x, leftJaw.y + ctx.canvas.height*0.035);
      drop(rightJaw.x, rightJaw.y + ctx.canvas.height*0.035);

      ctx.restore();

      function drop(x,y){
        ctx.beginPath(); ctx.arc(x, y, r, 0, Math.PI*2); ctx.fill(); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(x, y+r); ctx.lineTo(x, y+r*(HQ?6.4:6.0)); ctx.stroke();
        ctx.beginPath(); ctx.arc(x, y+r*(HQ?7.9:7.3), r*1.35, 0, Math.PI*2); ctx.fill(); ctx.stroke();
        radialGlow(ctx, x + r*1.2, y + r*(HQ?7.5:6.9), r*4.0, "rgba(255,255,255,0.35)");
      }
    }

    // ----- Boot -----
    setValLabels();
  </script>
</body>
</html>
