<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>AIë·°í‹°ì‹œë®¬ë ˆì´í„° â€” ë” í‹° ë‚˜ê²Œ (Before/After ìŠ¬ë¼ì´ë”)</title>
  <meta name="description" content="ë‚´ ì–¼êµ´ ëœë“œë§ˆí¬ ê¸°ë°˜ 3D ì„±í˜• ì‹œë®¬ë ˆì´ì…˜. ëˆˆ/ì½”/ì…/ìœ¤ê³½ êµ¬ì¡° ë³€í™”ì™€ Before/After ë“œë˜ê·¸ ë¹„êµë¥¼ ì œê³µí•©ë‹ˆë‹¤." />
  <style>
    :root{
      --bg:#070A14;
      --line: rgba(255,255,255,.14);
      --text:#EAF0FF;
      --sub:#AAB6D6;
      --good:#35F0B5;
      --mid:#6D7CFF;
      --gold:#FFD36E;
      --shadow: 0 18px 55px rgba(0,0,0,.50);
      --r:20px;
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Apple SD Gothic Neo", "Noto Sans KR", Arial;
      color:var(--text);
      background:
        radial-gradient(1200px 720px at 18% 0%, rgba(109,124,255,.22), transparent 60%),
        radial-gradient(900px 650px at 90% 10%, rgba(53,240,181,.16), transparent 55%),
        radial-gradient(900px 650px at 55% 115%, rgba(255,211,110,.10), transparent 55%),
        linear-gradient(180deg, var(--bg), #030411 78%);
      overflow-x:hidden;
    }
    .wrap{max-width:1250px;margin:0 auto;padding:18px 16px 34px;}
    .topbar{
      display:flex; align-items:center; justify-content:space-between; gap:12px; flex-wrap:wrap;
      padding:14px 14px;
      border:1px solid var(--line);
      background: linear-gradient(180deg, rgba(255,255,255,.08), rgba(255,255,255,.03));
      border-radius: var(--r);
      box-shadow: var(--shadow);
    }
    .brand{display:flex;align-items:center;gap:12px;flex:1;min-width:280px}
    .logo{
      width:44px;height:44px;border-radius:14px;
      background: conic-gradient(from 210deg, rgba(109,124,255,.95), rgba(53,240,181,.90), rgba(255,211,110,.88), rgba(109,124,255,.95));
      box-shadow: 0 12px 30px rgba(109,124,255,.22);
      position:relative;
    }
    .logo:after{
      content:"";position:absolute;inset:9px;border-radius:12px;
      background: rgba(8,10,20,.78);
      border:1px solid rgba(255,255,255,.10);
    }
    h1{margin:0;font-size:16px;letter-spacing:-.02em}
    .sub{color:var(--sub);font-size:12px;line-height:1.55;margin-top:4px}
    .grid{margin-top:14px;display:grid;gap:14px;grid-template-columns: 1.25fr .75fr;}
    @media (max-width: 980px){ .grid{grid-template-columns:1fr;} }
    .card{
      border:1px solid var(--line);
      background: linear-gradient(180deg, rgba(255,255,255,.07), rgba(255,255,255,.03));
      border-radius: var(--r);
      box-shadow: var(--shadow);
      overflow:hidden;
    }
    .hd{
      padding:14px 14px 10px;
      border-bottom:1px solid rgba(255,255,255,.08);
      display:flex;justify-content:space-between;align-items:flex-start;gap:12px;flex-wrap:wrap;
      background: linear-gradient(180deg, rgba(255,255,255,.07), rgba(255,255,255,.00));
    }
    .title{font-weight:950;font-size:13px;letter-spacing:-.01em}
    .hint{color:var(--sub);font-size:12px;margin-top:6px;line-height:1.55}
    .bd{padding:14px;}
    .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
    .langWrap{
      display:flex;
      align-items:center;
      gap:8px;
      padding:8px 10px;
      border:1px solid rgba(255,255,255,.12);
      border-radius: 14px;
      background: rgba(255,255,255,.05);
    }
    .langSelect{
      min-width:130px;
      width:auto;
      padding:8px 10px;
      border-radius:10px;
      font-size:12px;
    }
    .btn{
      border:1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.06);
      color: var(--text);
      padding:10px 12px;
      border-radius: 14px;
      font-weight:900;
      cursor:pointer;
      transition:.15s transform,.15s background,.15s border-color;
      user-select:none;
      white-space:nowrap;
    }
    .btn:hover{transform: translateY(-1px); background: rgba(255,255,255,.10); border-color: rgba(255,255,255,.22); }
    .btn.primary{ background: linear-gradient(90deg, rgba(109,124,255,.28), rgba(53,240,181,.18)); border-color: rgba(109,124,255,.55); }
    .btn.gold{ background: linear-gradient(90deg, rgba(255,211,110,.26), rgba(109,124,255,.16)); border-color: rgba(255,211,110,.52); }
    .btn.danger{ background: rgba(255,91,122,.12); border-color: rgba(255,91,122,.45); }
    .pill{
      display:inline-flex;gap:8px;align-items:center;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.06);
      border-radius: 999px;
      padding: 6px 10px;
      font-size: 12px;
      margin: 6px 6px 0 0;
    }
    .dot{width:9px;height:9px;border-radius:999px;background:var(--good)}
    .dot.mid{background:var(--mid)}
    .dot.gold{background:var(--gold)}
    .canvasWrap{display:grid;gap:12px}
    .stage{
      position:relative;
      border-radius: 18px;
      border:1px solid rgba(255,255,255,.10);
      background: rgba(4,6,16,.55);
      overflow:hidden;
      touch-action:none;
    }
    canvas{
      width:100%;
      height:auto;
      display:block;
      background: transparent;
    }
    .sliderUI{
      position:absolute; inset:0;
      pointer-events:none;
    }
    .divider{
      position:absolute; top:0; bottom:0;
      width:3px;
      background: rgba(255,255,255,.85);
      box-shadow: 0 0 0 1px rgba(0,0,0,.25);
    }
    .handle{
      position:absolute; top:50%;
      width:46px; height:46px;
      border-radius: 999px;
      transform: translate(-50%, -50%);
      background: rgba(0,0,0,.45);
      border:1px solid rgba(255,255,255,.18);
      backdrop-filter: blur(10px);
      box-shadow: var(--shadow);
      display:flex;align-items:center;justify-content:center;
      color: rgba(255,255,255,.9);
      font-weight: 950;
      font-size: 18px;
    }
    .tag{
      position:absolute; top:12px;
      padding:6px 10px;
      border-radius:999px;
      font-size:12px;
      font-weight:950;
      border:1px solid rgba(255,255,255,.16);
      background: rgba(0,0,0,.35);
      color: rgba(255,255,255,.9);
      pointer-events:none;
    }
    .tag.left{left:12px}
    .tag.right{right:12px}
    .toggle{
      display:flex;gap:10px;flex-wrap:wrap;align-items:center;justify-content:space-between;
      padding:10px 12px;border-radius:18px;border:1px solid rgba(255,255,255,.10);background:rgba(255,255,255,.05);
    }
    .tiny{font-size:12px;color:var(--sub);line-height:1.6}
    .warn{
      margin-top:10px;
      padding:12px;
      border-radius:18px;
      border:1px solid rgba(255,211,110,.25);
      background: rgba(255,211,110,.06);
      color: var(--sub);
      font-size:12px;
      line-height:1.6;
    }
    .control{
      padding:12px;
      border-radius: 18px;
      border:1px solid rgba(255,255,255,.10);
      background: rgba(255,255,255,.05);
      margin-bottom:10px;
    }
    .control .top{display:flex;justify-content:space-between;gap:10px;align-items:center}
    .control .name{font-weight:950;font-size:12px}
    .control .val{font-size:12px;color:var(--sub);font-family:ui-monospace, Menlo, Monaco, Consolas, monospace}
    input[type="range"]{width:100%}
    select, input[type="color"]{
      width:100%;
      background: rgba(7,10,20,.62);
      border:1px solid rgba(255,255,255,.14);
      color: var(--text);
      border-radius: 14px;
      padding: 10px 12px;
      outline:none;
    }
    .split{display:grid;gap:10px;grid-template-columns:1fr 1fr}
    @media (max-width: 520px){ .split{grid-template-columns:1fr} }
    .mono{font-family: ui-monospace, Menlo, Monaco, Consolas, monospace;}
    .badge{
      display:inline-flex;align-items:center;gap:8px;
      font-size:12px;font-weight:950;
      padding:6px 10px;border-radius:999px;
      border:1px solid rgba(255,255,255,.14);
      background:rgba(255,255,255,.06);
      white-space:nowrap;
    }
    .k{display:flex;gap:8px;flex-wrap:wrap}
    .ck{display:flex;align-items:center;gap:8px}
    .ck input{accent-color:#7aa7ff}
    .makeup-control{display:none !important;}
    .stack{margin-top:14px;display:grid;gap:14px}
    .contentCard{
      border:1px solid var(--line);
      border-radius: var(--r);
      background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.02));
      box-shadow: var(--shadow);
      padding:14px;
    }
    .contentTitle{font-size:18px;font-weight:950;letter-spacing:-.02em}
    .contentSub{margin-top:8px;color:var(--sub);font-size:13px;line-height:1.7}
    .quickGrid{display:grid;gap:10px;grid-template-columns:repeat(3,minmax(0,1fr));margin-top:12px}
    .quickItem{
      border:1px solid rgba(255,255,255,.12);
      border-radius:16px;
      background: rgba(255,255,255,.04);
      padding:10px;
      font-size:12px;
      line-height:1.6;
    }
    .uxGrid{display:grid;gap:12px;grid-template-columns:1fr 1fr;margin-top:12px}
    .lookDeck{
      border:1px solid rgba(255,255,255,.12);
      border-radius:16px;
      background: rgba(255,255,255,.04);
      padding:12px;
    }
    .lookHead{display:flex;justify-content:space-between;gap:10px;align-items:center}
    .lookName{font-weight:900;font-size:14px}
    .scoreWrap{margin-top:8px}
    .scoreTop{display:flex;justify-content:space-between;gap:8px;font-size:12px;color:var(--sub)}
    .scoreBar{
      margin-top:6px;
      height:10px;
      border-radius:999px;
      background: rgba(255,255,255,.08);
      overflow:hidden;
    }
    .scoreFill{
      height:100%;
      width:0%;
      background: linear-gradient(90deg, rgba(255,211,110,.9), rgba(53,240,181,.9));
      transition:width .25s ease;
    }
    .lookMeta{margin-top:8px;color:var(--sub);font-size:12px;line-height:1.6}
    .savedList{display:grid;gap:8px;margin-top:10px}
    .savedItem{
      border:1px solid rgba(255,255,255,.1);
      border-radius:12px;
      padding:8px 10px;
      background: rgba(0,0,0,.18);
      display:flex;justify-content:space-between;gap:8px;align-items:center;
      font-size:12px;
    }
    .savedItem button{
      border:1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.08);
      color: var(--text);
      border-radius:10px;
      padding:6px 8px;
      cursor:pointer;
      font-size:11px;
      font-weight:800;
    }
    .infoGrid{display:grid;gap:12px;grid-template-columns:1fr 1fr 1fr}
    .faqItem{
      border:1px solid rgba(255,255,255,.1);
      border-radius:14px;
      background: rgba(255,255,255,.03);
      padding:10px;
    }
    .faqQ{font-weight:900;font-size:13px}
    .faqA{color:var(--sub);font-size:12px;line-height:1.7;margin-top:6px}
    .policyBar{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      margin-top:12px;
    }
    .policyLink{
      border:1px solid rgba(255,255,255,.14);
      border-radius:999px;
      padding:8px 12px;
      font-size:12px;
      color:var(--text);
      text-decoration:none;
      background: rgba(255,255,255,.04);
    }
    .policyLink:hover{background:rgba(255,255,255,.1)}
    .footNote{
      margin-top:10px;
      color:var(--sub);
      font-size:12px;
      line-height:1.7;
    }
    @media (max-width: 900px){
      .wrap{padding:12px 10px 20px;}
      .topbar{padding:12px; gap:10px;}
      h1{font-size:15px;}
      .row{width:100%;}
      .row .btn{flex:1 1 calc(50% - 6px); min-height:44px; text-align:center; justify-content:center;}
      .row label.btn{display:flex !important;}
      .langWrap{width:100%; justify-content:space-between;}
      .langSelect{flex:1;}
      .hd{padding:12px 12px 9px;}
      .bd{padding:12px;}
      .pill{font-size:11px;}
      .control{padding:10px;}
      .quickGrid{grid-template-columns:1fr;}
      .uxGrid{grid-template-columns:1fr;}
      .infoGrid{grid-template-columns:1fr;}
    }
    @media (max-width: 520px){
      .row .btn{flex:1 1 100%;}
      .handle{width:42px;height:42px;font-size:16px;}
      .tag{font-size:11px;padding:5px 8px;}
    }
  </style>
</head>

<body>
  <div class="wrap">
    <div class="topbar">
      <div class="brand">
        <div class="logo" aria-hidden="true"></div>
        <div>
          <h1><span id="appTitle">AIë·°í‹°ì‹œë®¬ë ˆì´í„°</span> <span id="appSubtitle" style="color:var(--sub);font-weight:800;">â€” ìì—°ìŠ¤ëŸ¬ìš´ Before-After ë“œë˜ê·¸</span></h1>
          <div class="sub" id="topSub">
            âœ… ë¸Œë¼ìš°ì €ì—ì„œë§Œ ì²˜ë¦¬(ì„œë²„ ì—…ë¡œë“œ ì—†ìŒ) Â· âœ… ìì—°ìŠ¤ëŸ¬ìš´ AI ëœë“œë§ˆí¬ ê¸°ë°˜ ë³´ì • Â· âœ… ì°¸ê³ ìš© ì‹œë®¬ë ˆì´ì…˜
          </div>
        </div>
      </div>
      <div class="row">
        <div class="langWrap">
          <label class="tiny" id="lblLang" for="langSelect">ì–¸ì–´</label>
          <select id="langSelect" class="langSelect" aria-label="Language">
            <option value="ko">í•œêµ­ì–´</option>
            <option value="en">English</option>
            <option value="ja">æ—¥æœ¬èª</option>
            <option value="es">EspaÃ±ol</option>
            <option value="fr">FranÃ§ais</option>
            <option value="de">Deutsch</option>
          </select>
        </div>
        <button class="btn" id="btnUseCamera">ì¹´ë©”ë¼ ì‚¬ìš©</button>
        <label class="btn" style="display:inline-flex;align-items:center;gap:10px;">
          <span id="labelUpload">ì‚¬ì§„ ì—…ë¡œë“œ</span>
          <input id="file" type="file" accept="image/*" style="display:none">
        </label>
        <button class="btn gold" id="btnSave" disabled>ì´ë¯¸ì§€ ì €ì¥</button>
        <button class="btn danger" id="btnReset">ì´ˆê¸°í™”</button>
      </div>
    </div>

    <div class="grid">
      <!-- LEFT: PREVIEW -->
      <section class="card">
        <div class="hd">
          <div>
            <div class="title" id="previewTitle">ğŸª ë¯¸ë¦¬ë³´ê¸°</div>
            <div class="hint">
              <span class="pill"><span class="dot"></span><span id="pillCompare">ìŠ¬ë¼ì´ë” ë“œë˜ê·¸ë¡œ Before/After ë¹„êµ</span></span>
              <span class="pill"><span class="dot mid"></span><span id="pillDepth">ìœ¤ê³½ í•€ì¹˜ + ê´‘(í•˜ì´ë¼ì´íŠ¸)ë¡œ â€œ2.5D ì°©ì‹œâ€</span></span>
              <span class="pill"><span class="dot gold"></span><span id="pillHair">í—¤ì–´(ì•ë¨¸ë¦¬/ë‹¨ë°œ/ì¥ë°œ) ì˜¤ë²„ë ˆì´</span></span>
            </div>
          </div>
          <div class="row">
            <button class="btn primary" id="btnPresetNatural" disabled>í”„ë¦¬ì…‹: ìì—°</button>
            <button class="btn" id="btnPresetDramatic" disabled>í”„ë¦¬ì…‹: ë“œë¼ë§ˆí‹±</button>
            <button class="btn" id="btnPresetGlow" disabled>í”„ë¦¬ì…‹: ê´‘íƒ</button>
          </div>
        </div>
        <div class="bd">
          <div class="canvasWrap">
            <div class="stage" id="stage">
              <!-- result canvas -->
              <canvas id="view" width="1280" height="960"></canvas>

              <!-- UI overlay -->
              <div class="sliderUI" id="sliderUI">
                <div class="tag left" id="tagBefore">BEFORE</div>
                <div class="tag right" id="tagAfter">AFTER</div>
                <div class="divider" id="divider"></div>
                <div class="handle" id="handle">â†”</div>
              </div>
            </div>

            <div class="toggle">
              <div class="tiny">
                <span class="badge" id="tipBadge">íŒ</span>
                <span id="tipText">ëˆˆ/ì½”/ì…/ìœ¤ê³½ì„ ë‚®ì€ ê°•ë„ë¶€í„° ì¡°ì •í•˜ë©´ ì‹¤ì œ ìˆ˜ìˆ  í›„ ì¸ìƒì„ ë” í˜„ì‹¤ì ìœ¼ë¡œ ë¹„êµí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.</span>
              </div>
              <div class="k">
                <label class="ck tiny"><input type="checkbox" id="chkMirror" checked> <span id="lblMirror">ê±°ìš¸</span></label>
                <label class="ck tiny"><input type="checkbox" id="chkLandmarks"> <span id="lblLandmarks">ëœë“œë§ˆí¬</span></label>
                <label class="ck tiny"><input type="checkbox" id="chkHQ" checked> <span id="lblHQ">ê³ í™”ì§ˆ</span></label>
                <label class="ck tiny"><input type="checkbox" id="chk3D" checked> <span id="lbl3D">3D ë Œë”</span></label>
              </div>
            </div>

            <div class="warn" id="warnText">
              <b id="warnTitle">ë©´ì±…</b> : <span id="warnBody">ë³¸ ì„œë¹„ìŠ¤ëŠ” ì˜¤ë½ ë° ìŠ¤íƒ€ì¼ ì°¸ê³ ìš© ì‹œë®¬ë ˆì´ì…˜ì…ë‹ˆë‹¤. ì‹¤ì œ ì‹œìˆ /ìˆ˜ìˆ  ê²°ê³¼ë¥¼ ì˜ˆì¸¡í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.</span>
            </div>
          </div>
        </div>
      </section>

      <!-- RIGHT: CONTROLS -->
      <aside class="card">
        <div class="hd">
          <div>
            <div class="title" id="controlsTitle">ğŸ›ï¸ 3D ì„±í˜• ì‹œë®¬ë ˆì´ì…˜ ì»¨íŠ¸ë¡¤</div>
            <div class="hint" id="controlsHint">ë©”ì´í¬ì—… íš¨ê³¼ ì—†ì´ ì–¼êµ´ êµ¬ì¡° ë³€í™”ë§Œ ë°˜ì˜í•´ ìˆ˜ìˆ  í›„ ì¸ìƒì„ í˜„ì‹¤ì ìœ¼ë¡œ ê°€ëŠ í•©ë‹ˆë‹¤.</div>
          </div>
        </div>

        <div class="bd">
          <div class="control">
            <div class="top"><div class="name">ì „ì²´ ê°•ë„</div><div class="val" id="vPower">65</div></div>
            <input type="range" id="power" min="0" max="100" value="65">
            <div class="desc">ëª¨ë“  ë³€í˜•/ë©”ì´í¬ì—…/ìœ¤ê³½ íš¨ê³¼ì˜ â€œë§ˆìŠ¤í„° ê²Œì¸â€</div>
          </div>

          <div class="split">
            <div class="control">
              <div class="top"><div class="name">ëˆˆ í¬ê¸°</div><div class="val" id="vEye">20</div></div>
              <input type="range" id="eye" min="-40" max="80" value="20">
              <div class="desc">ëˆˆ í™•ëŒ€/ì¶•ì†Œ</div>
            </div>
            <div class="control">
              <div class="top"><div class="name">ëˆˆ ê°„ê²©</div><div class="val" id="vEyeSpace">6</div></div>
              <input type="range" id="eyeSpace" min="-40" max="40" value="6">
              <div class="desc">ëˆˆì„ ì•ˆ/ë°–ìœ¼ë¡œ ì´ë™</div>
            </div>
          </div>

          <div class="split">
            <div class="control">
              <div class="top"><div class="name">ì½” í­</div><div class="val" id="vNoseW">-10</div></div>
              <input type="range" id="noseW" min="-55" max="55" value="-10">
              <div class="desc">ì½§ë³¼ ëŠë‚Œ(ê°€ë¡œ ì›Œí”„)</div>
            </div>
            <div class="control">
              <div class="top"><div class="name">ì½” â€˜ë†’ì•„ë³´ì„â€™</div><div class="val" id="vNoseH">45</div></div>
              <input type="range" id="noseH" min="0" max="100" value="45">
              <div class="desc">ì½§ëŒ€ í•˜ì´ë¼ì´íŠ¸ + ì–‘ì˜† ì‰ë”© ê°•í™”</div>
            </div>
          </div>

          <div class="split">
            <div class="control">
              <div class="top"><div class="name">ì…ìˆ  ë³¼ë¥¨</div><div class="val" id="vLip">18</div></div>
              <input type="range" id="lip" min="-40" max="65" value="18">
              <div class="desc">ì…ìˆ  í™•ëŒ€/ì¶•ì†Œ</div>
            </div>
            <div class="control">
              <div class="top"><div class="name">í„±/ìœ¤ê³½</div><div class="val" id="vSlim">35</div></div>
              <input type="range" id="slim" min="0" max="100" value="35">
              <div class="desc">ë³¼/í„± ë¼ì¸ì„ ì¤‘ì•™ìœ¼ë¡œ í•€ì¹˜(ì²´ê° í¼)</div>
            </div>
          </div>

          <div class="control">
            <div class="top"><div class="name">í„± Shape</div><div class="val" id="vJawShape">0</div></div>
            <input type="range" id="jawShape" min="-50" max="50" value="0">
            <div class="desc">ìŒìˆ˜ëŠ” ë¶€ë“œëŸ¬ìš´ Vë¼ì¸, ì–‘ìˆ˜ëŠ” ê°ì§„ í„± ë¼ì¸ìœ¼ë¡œ ì¡°ì ˆ</div>
          </div>

          <div class="split makeup-control">
            <div class="control">
              <div class="top"><div class="name">í”¼ë¶€ ë³´ì •</div><div class="val" id="vSkin">35</div></div>
              <input type="range" id="skin" min="0" max="100" value="35">
              <div class="desc">ì–¼êµ´ ì˜ì—­ ìŠ¤ë¬´ë”© + í†¤</div>
            </div>
            <div class="control">
              <div class="top"><div class="name">ì»¨íˆ¬ì–´(ì‰ë”©)</div><div class="val" id="vContour">35</div></div>
              <input type="range" id="contour" min="0" max="100" value="35">
              <div class="desc">ê´‘ëŒ€/í„±/ì½” ì˜† ì‰ë”©</div>
            </div>
          </div>

          <div class="split makeup-control">
            <div class="control">
              <div class="top"><div class="name">ë¸”ëŸ¬ì…”</div><div class="val" id="vBlush">30</div></div>
              <input type="range" id="blush" min="0" max="100" value="30">
              <div class="desc">ì¹˜í¬ ì»¬ëŸ¬</div>
            </div>
            <div class="control">
              <div class="top"><div class="name">ì•„ì´ë¼ì¸</div><div class="val" id="vLiner">45</div></div>
              <input type="range" id="liner" min="0" max="100" value="45">
              <div class="desc">ìœ—ë¼ì¸/ëˆˆê¼¬ë¦¬ ê°•ì¡°</div>
            </div>
          </div>

          <div class="split makeup-control">
            <div class="control">
              <div class="top"><div class="name">ë¦½ ì»¬ëŸ¬</div><div class="val" id="vLipColor">#ff3e7a</div></div>
              <input type="color" id="lipColor" value="#ff3e7a">
              <div class="desc">ì…ìˆ  ìƒ‰ìƒ</div>
            </div>
            <div class="control">
              <div class="top"><div class="name">ë¦½ ê¸€ë¡œìŠ¤</div><div class="val" id="vGloss">35</div></div>
              <input type="range" id="gloss" min="0" max="100" value="35">
              <div class="desc">ì…ìˆ  ê´‘(2.5D ì²´ê°â†‘)</div>
            </div>
          </div>

          <div class="control makeup-control">
            <div class="top"><div class="name">í—¤ì–´ ìŠ¤íƒ€ì¼</div><div class="val" id="vHairStyle">ì•ë¨¸ë¦¬</div></div>
            <select id="hairStyle">
              <option value="none">ì—†ìŒ</option>
              <option value="bangs" selected>ì•ë¨¸ë¦¬</option>
              <option value="bob">ë‹¨ë°œ(ë³´ë¸Œ)</option>
              <option value="long">ì¥ë°œ</option>
            </select>
            <div class="desc">ì •ë°€ ì„¸ê·¸ë©˜í…Œì´ì…˜ ëŒ€ì‹  â€œì–¼êµ´ ì™¸ê³½/ì´ë§ˆ í¬ì¸íŠ¸â€ ê¸°ë°˜ìœ¼ë¡œ ê·¸ëŸ´ë“¯í•œ ì˜¤ë²„ë ˆì´ë¥¼ ë§Œë“­ë‹ˆë‹¤(í‹° ë§ì´ ë‚¨).</div>
          </div>

          <div class="split makeup-control">
            <div class="control">
              <div class="top"><div class="name">í—¤ì–´ ì»¬ëŸ¬</div><div class="val" id="vHairColor">#2b1a14</div></div>
              <input type="color" id="hairColor" value="#2b1a14">
              <div class="desc">í—¤ì–´ ì˜¤ë²„ë ˆì´ ìƒ‰</div>
            </div>
            <div class="control">
              <div class="top"><div class="name">ì•…ì„¸ì„œë¦¬</div><div class="val" id="vAcc">ON</div></div>
              <label class="ck tiny"><input type="checkbox" id="glasses" checked> <span id="lblGlasses">ì•ˆê²½</span></label>
              <label class="ck tiny"><input type="checkbox" id="earrings" checked> <span id="lblEarrings">ê·€ê±¸ì´</span></label>
              <div class="desc">ëˆˆ/í„± ìœ„ì¹˜ ê¸°ë°˜ ì˜¤ë²„ë ˆì´</div>
            </div>
          </div>

          <div class="tiny" style="margin-top:12px;" id="shootTipText">
            <b id="shootTipTitle">ì´¬ì˜ íŒ</b><br/>
            <span id="shootTipBody">ì •ë©´ + ë°ì€ ì¡°ëª… + ì–¼êµ´ì´ í¬ê²Œ ë‚˜ì˜¤ë©´(ì´ë§ˆ~í„±) í›¨ì”¬ ìì—°ìŠ¤ëŸ½ê³  í‹°ê°€ ì˜ ë‚©ë‹ˆë‹¤.</span>
          </div>
        </div>
      </aside>
    </div>

    <section class="stack">
      <article class="contentCard">
        <div class="contentTitle" id="growthTitle">AIë·°í‹°ì‹œë®¬ë ˆì´í„°ë¥¼ â€œë„êµ¬â€ê°€ ì•„ë‹ˆë¼ â€œì½˜í…ì¸ í˜• ì„œë¹„ìŠ¤â€ë¡œ ìš´ì˜í•˜ê¸°</div>
        <div class="contentSub" id="growthSub">AdSense ì‹¬ì‚¬ ê´€ì ì—ì„œ ì¤‘ìš”í•œ ê²ƒì€ ê´‘ê³  ë°°ì¹˜ë³´ë‹¤ í˜ì´ì§€ ê°€ì¹˜ì…ë‹ˆë‹¤. ì´ í˜ì´ì§€ëŠ” ì²´í—˜+ì„¤ëª…+ê°€ì´ë“œ+ì‹ ë¢° ìš”ì†Œë¥¼ í•¨ê»˜ ì œê³µí•˜ë„ë¡ ì„¤ê³„ë˜ì–´ ìˆìŠµë‹ˆë‹¤.</div>
        <div class="quickGrid">
          <div class="quickItem"><b id="kpi1Title">í”„ë¡œì íŠ¸í™”</b><br/><span id="kpi1Body">1íšŒ ì²´í—˜ì´ ì•„ë‹ˆë¼ ì €ì¥/ë¹„êµë¡œ ì´ì–´ì ¸ ì¬ë°©ë¬¸ì„ ë§Œë“­ë‹ˆë‹¤.</span></div>
          <div class="quickItem"><b id="kpi2Title">ì¶”ì²œ ë£¨í”„</b><br/><span id="kpi2Body">ë£© ì¹´ë“œ ë±ìœ¼ë¡œ â€œë‹¤ìŒ ì¶”ì²œâ€ì„ ê³„ì† íƒìƒ‰í•˜ê²Œ ë§Œë“­ë‹ˆë‹¤.</span></div>
          <div class="quickItem"><b id="kpi3Title">ì‹ ë¢° ìš”ì†Œ</b><br/><span id="kpi3Body">ë©´ì±…/FAQ/ì •ì±… ë§í¬ë¥¼ ëª…í™•íˆ ì œê³µí•´ í’ˆì§ˆ ì‹ í˜¸ë¥¼ ê°•í™”í•©ë‹ˆë‹¤.</span></div>
        </div>
      </article>

      <article class="contentCard">
        <div class="contentTitle" id="deckTitle">ì˜¤ëŠ˜ì˜ AI ë£© ì¹´ë“œ ë±</div>
        <div class="contentSub" id="deckSub">ì™¸ëª¨ í‰ê°€ê°€ ì•„ë‹Œ ìŠ¤íƒ€ì¼ ê· í˜• ì ìˆ˜ë¡œ ì§„í–‰ë¥ ì„ ë³´ì—¬ì£¼ê³ , ì €ì¥í•œ ë£©ì„ ë‹¤ì‹œ ë¶ˆëŸ¬ì™€ ë¹„êµí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.</div>
        <div class="uxGrid">
          <div class="lookDeck">
            <div class="lookHead">
              <div class="lookName" id="lookName">ì¶”ì²œ ë£©: ì†Œí”„íŠ¸ ë³¼ë¥¨ ë°ì´</div>
              <span class="badge" id="lookIndex">1 / 10</span>
            </div>
            <div class="lookMeta" id="lookMeta">í—¤ì–´Â·ë¦½Â·ìœ¤ê³½ ì¡°í•©ì„ ìë™ ì¶”ì²œí•©ë‹ˆë‹¤.</div>
            <div class="scoreWrap">
              <div class="scoreTop">
                <span id="scoreLabel">ìŠ¤íƒ€ì¼ ê· í˜• ì ìˆ˜</span>
                <span id="scoreValue">72%</span>
              </div>
              <div class="scoreBar"><div class="scoreFill" id="scoreFill"></div></div>
            </div>
            <div class="row" style="margin-top:10px;">
              <button class="btn primary" id="btnApplyLook">ë£© ì ìš©</button>
              <button class="btn" id="btnNextLook">ë‹¤ìŒ ì¶”ì²œ</button>
              <button class="btn gold" id="btnSaveLook">ë£© ì €ì¥</button>
            </div>
          </div>
          <div class="lookDeck">
            <div class="lookHead">
              <div class="lookName" id="savedTitle">ì €ì¥í•œ ë£© ë¹„êµ</div>
              <span class="badge" id="savedCount">0ê°œ</span>
            </div>
            <div class="lookMeta" id="savedSub">ì €ì¥í•œ ë£©ì€ ì•„ë˜ ëª©ë¡ì—ì„œ ì¦‰ì‹œ ë‹¤ì‹œ ì ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.</div>
            <div class="savedList" id="savedList"></div>
          </div>
        </div>
      </article>

      <article class="contentCard">
        <div class="contentTitle" id="guideTitle">ì‚¬ìš© ê°€ì´ë“œ & ì‹ ë¢° ì •ë³´</div>
        <div class="infoGrid" style="margin-top:12px;">
          <div class="faqItem">
            <div class="faqQ" id="faqQ1">ì‹œë®¬ë ˆì´í„°ëŠ” ì–´ë–»ê²Œ ì‘ë™í•˜ë‚˜ìš”?</div>
            <div class="faqA" id="faqA1">ì–¼êµ´ ëœë“œë§ˆí¬ ê¸°ë°˜ 2D ì›Œí”„ì™€ ìƒ‰ ë³´ì •ì„ ì¡°í•©í•´ ì „/í›„ ë³€í™”ë¥¼ ì‹œê°í™”í•©ë‹ˆë‹¤.</div>
          </div>
          <div class="faqItem">
            <div class="faqQ" id="faqQ2">ì™œ í—¤ì–´/ê´‘íƒ ì˜µì…˜ì´ ì¤‘ìš”í•˜ë‚˜ìš”?</div>
            <div class="faqA" id="faqA2">í—¤ì–´ ì‹¤ë£¨ì—£ê³¼ í•˜ì´ë¼ì´íŠ¸ëŠ” ì–¼êµ´ ì¸ìƒì„ í¬ê²Œ ë°”ê¾¸ê¸° ë•Œë¬¸ì— ì²´ê°ì´ ê°€ì¥ í½ë‹ˆë‹¤.</div>
          </div>
          <div class="faqItem">
            <div class="faqQ" id="faqQ3">ì˜í•™ì  ê²°ê³¼ë¥¼ ë³´ì¥í•˜ë‚˜ìš”?</div>
            <div class="faqA" id="faqA3">ì•„ë‹ˆìš”. ë³¸ ì„œë¹„ìŠ¤ëŠ” ì˜¤ë½ ë° ìŠ¤íƒ€ì¼ ì°¸ê³ ìš© ì‹œë®¬ë ˆì´ì…˜ì´ë©° ì‹¤ì œ ê²°ê³¼ë¥¼ ì˜ˆì¸¡í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.</div>
          </div>
        </div>
        <div class="policyBar">
          <a class="policyLink" href="#" id="lnkPrivacy">Privacy Policy</a>
          <a class="policyLink" href="#" id="lnkAbout">About</a>
          <a class="policyLink" href="#" id="lnkContact">Contact</a>
          <a class="policyLink" href="#" id="lnkDisclaimer">Disclaimer</a>
        </div>
        <div class="footNote" id="footerNote">ì •ì±… í˜ì´ì§€ëŠ” ì‹¤ì œ ìš´ì˜ ì •ë³´ì— ë§ê²Œ ë³„ë„ ë¬¸ì„œë¡œ ì—°ê²°í•˜ì„¸ìš”. (AdSense ì‹¬ì‚¬ ì‹œ í•„ìˆ˜)</div>
      </article>
    </section>
  </div>

  <video id="video" playsinline style="display:none"></video>
  <canvas id="src" width="1280" height="960" style="display:none"></canvas>

  <!-- MediaPipe -->
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.161.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/delaunator@5.0.1/delaunator.min.js"></script>

  <script>
    // =========================================================
    // â€œë” í‹° ë‚˜ê²Œâ€ í¬ì¸íŠ¸
    // 1) Before/After ë“œë˜ê·¸ ìŠ¬ë¼ì´ë”(ì²´ê° í­ë°œ)
    // 2) ìœ¤ê³½ í•€ì¹˜(ì†Œí”„íŠ¸ ì›Œí”„) + ì»¨íˆ¬ì–´/í•˜ì´ë¼ì´íŠ¸ ê°•í™”ë¡œ 2.5D ì°©ì‹œ
    // 3) í—¤ì–´ìŠ¤íƒ€ì¼(ì•ë¨¸ë¦¬/ë‹¨ë°œ/ì¥ë°œ) ì˜¤ë²„ë ˆì´: ë³€í™”ê°€ ê°€ì¥ ëˆˆì— ë„ëŠ” ìš”ì†Œ
    // =========================================================

    const view = $('view');
    const vctx = view.getContext('2d');

    const src = $('src');
    const sctx = src.getContext('2d');

    const video = $('video');
    const file = $('file');

    // offscreen: before/after render
    const beforeC = document.createElement('canvas');
    beforeC.width = view.width; beforeC.height = view.height;
    const bctx = beforeC.getContext('2d');

    const afterC = document.createElement('canvas');
    afterC.width = view.width; afterC.height = view.height;
    const actx = afterC.getContext('2d');

    // offscreen: 3D render
    const glC = document.createElement('canvas');
    glC.width = view.width; glC.height = view.height;
    const glctx = glC.getContext('2d');

    const stage = $('stage');
    const divider = $('divider');
    const handle = $('handle');
    const langSelect = $('langSelect');

    let splitX = 0.55; // 0..1
    let dragging = false;

    // UI elements
    const chkMirror = $('chkMirror');
    const chkLandmarks = $('chkLandmarks');
    const chkHQ = $('chkHQ');
    const chk3D = $('chk3D');

    const btnUseCamera = $('btnUseCamera');
    const btnSave = $('btnSave');
    const btnReset = $('btnReset');

    const btnPresetNatural = $('btnPresetNatural');
    const btnPresetDramatic = $('btnPresetDramatic');
    const btnPresetGlow = $('btnPresetGlow');

    // controls
    const power = $('power');
    const eye = $('eye'), eyeSpace = $('eyeSpace');
    const noseW = $('noseW'), noseH = $('noseH');
    const lip = $('lip'), slim = $('slim'), jawShape = $('jawShape');
    const skin = $('skin'), contour = $('contour'), blush = $('blush'), liner = $('liner'), gloss = $('gloss');
    const lipColor = $('lipColor');
    const hairStyle = $('hairStyle');
    const hairColor = $('hairColor');
    const glasses = $('glasses');
    const earrings = $('earrings');

    // value labels
    const vPower = $('vPower');
    const vEye = $('vEye'), vEyeSpace = $('vEyeSpace');
    const vNoseW = $('vNoseW'), vNoseH = $('vNoseH');
    const vLip = $('vLip'), vSlim = $('vSlim'), vJawShape = $('vJawShape');
    const vSkin = $('vSkin'), vContour = $('vContour'), vBlush = $('vBlush'), vLiner = $('vLiner'), vGloss = $('vGloss');
    const vLipColor = $('vLipColor'), vHairStyle = $('vHairStyle'), vHairColor = $('vHairColor'), vAcc = $('vAcc');
    const lookName = $('lookName');
    const lookIndex = $('lookIndex');
    const lookMeta = $('lookMeta');
    const scoreValue = $('scoreValue');
    const scoreFill = $('scoreFill');
    const btnApplyLook = $('btnApplyLook');
    const btnNextLook = $('btnNextLook');
    const btnSaveLook = $('btnSaveLook');
    const savedList = $('savedList');
    const savedCount = $('savedCount');
    const controlNameEls = Array.from(document.querySelectorAll('.control .name'));
    const controlDescEls = Array.from(document.querySelectorAll('.control .desc'));

    function $(id){ return document.getElementById(id); }

    let usingCamera = false;
    let camera = null;
    let lastLandmarks = null;
    let smoothLandmarks = null;
    let lastFrameCanvas = null;
    let lastProcessAt = 0;
    let currentLang = 'ko';
    let lookPointer = 0;
    let currentLook = null;
    const savedLooks = [];

    const LOOK_TEMPLATES = [
      { key: 'soft_volume_day', name: { ko: 'ì†Œí”„íŠ¸ ë³¼ë¥¨ ë°ì´', en: 'Soft Volume Day' }, mood: { ko: 'ì€ì€í•œ ìœ¤ê³½ + ê´‘íƒ ì¤‘ì‹¬', en: 'Soft contour with gloss' }, settings: { power: 58, eye: 16, eyeSpace: 4, noseW: -8, noseH: 38, lip: 14, slim: 26, skin: 38, contour: 28, blush: 22, liner: 30, gloss: 44, hairStyle: 'bangs', hairColor: '#3b2519', lipColor: '#ff5f8f', glasses: false, earrings: true } },
      { key: 'city_chic', name: { ko: 'ì‹œí‹° ì‹œí¬', en: 'City Chic' }, mood: { ko: 'ë¼ì¸ ê°•ì¡° + ë³´ë¸Œ', en: 'Sharper lines + bob hair' }, settings: { power: 72, eye: 24, eyeSpace: 7, noseW: -12, noseH: 54, lip: 18, slim: 40, skin: 32, contour: 40, blush: 24, liner: 55, gloss: 36, hairStyle: 'bob', hairColor: '#241712', lipColor: '#d9386a', glasses: true, earrings: true } },
      { key: 'glow_event', name: { ko: 'ê¸€ë¡œìš° ì´ë²¤íŠ¸', en: 'Glow Event' }, mood: { ko: 'í•˜ì´ë¼ì´íŠ¸ + ë¡±í—¤ì–´', en: 'High highlight + long hair' }, settings: { power: 76, eye: 20, eyeSpace: 5, noseW: -10, noseH: 70, lip: 22, slim: 34, skin: 52, contour: 30, blush: 28, liner: 34, gloss: 74, hairStyle: 'long', hairColor: '#2d1b14', lipColor: '#ff4e86', glasses: false, earrings: true } },
      { key: 'clean_interview', name: { ko: 'í´ë¦° ì¸í„°ë·°', en: 'Clean Interview' }, mood: { ko: 'ìì—° í†¤ + ê· í˜•í˜•', en: 'Natural tone + balanced fit' }, settings: { power: 52, eye: 12, eyeSpace: 3, noseW: -6, noseH: 34, lip: 10, slim: 24, skin: 34, contour: 22, blush: 18, liner: 24, gloss: 26, hairStyle: 'none', hairColor: '#2b1a14', lipColor: '#e76c98', glasses: true, earrings: false } },
      { key: 'wedding_soft', name: { ko: 'ì›¨ë”© ì†Œí”„íŠ¸', en: 'Wedding Soft' }, mood: { ko: 'ë§‘ì€ í”¼ë¶€ + ì…ìˆ  í¬ì¸íŠ¸', en: 'Clear skin + lip focus' }, settings: { power: 66, eye: 18, eyeSpace: 4, noseW: -9, noseH: 50, lip: 20, slim: 30, skin: 50, contour: 26, blush: 30, liner: 30, gloss: 52, hairStyle: 'long', hairColor: '#3a2318', lipColor: '#ff6a9a', glasses: false, earrings: true } },
      { key: 'editorial_dark', name: { ko: 'ì—ë””í† ë¦¬ì–¼ ë‹¤í¬', en: 'Editorial Dark' }, mood: { ko: 'ê°•í•œ ì»¨íˆ¬ì–´ + ì„ ëª…í•œ ëˆˆë§¤', en: 'Strong contour + defined eyes' }, settings: { power: 82, eye: 28, eyeSpace: 8, noseW: -14, noseH: 62, lip: 16, slim: 46, skin: 30, contour: 48, blush: 20, liner: 66, gloss: 32, hairStyle: 'bob', hairColor: '#161011', lipColor: '#be315f', glasses: true, earrings: true } },
      { key: 'daily_glass', name: { ko: 'ë°ì¼ë¦¬ ê¸€ë˜ìŠ¤', en: 'Daily Glass' }, mood: { ko: 'ì•ˆê²½ ì¤‘ì‹¬ì˜ ë°ì¼ë¦¬ ë£©', en: 'Glasses-first daily look' }, settings: { power: 48, eye: 10, eyeSpace: 3, noseW: -5, noseH: 28, lip: 9, slim: 20, skin: 30, contour: 20, blush: 16, liner: 22, gloss: 20, hairStyle: 'bangs', hairColor: '#352117', lipColor: '#e05f8f', glasses: true, earrings: false } },
      { key: 'rose_party', name: { ko: 'ë¡œì¦ˆ íŒŒí‹°', en: 'Rose Party' }, mood: { ko: 'ë¸”ëŸ¬ì…”/ë¦½ ì¤‘ì‹¬ì˜ í™”ì‚¬í•œ í†¤', en: 'Blush and lip focused vivid tone' }, settings: { power: 70, eye: 22, eyeSpace: 6, noseW: -11, noseH: 46, lip: 24, slim: 32, skin: 40, contour: 30, blush: 40, liner: 42, gloss: 62, hairStyle: 'long', hairColor: '#44261d', lipColor: '#ff4f88', glasses: false, earrings: true } },
      { key: 'minimal_clean', name: { ko: 'ë¯¸ë‹ˆë©€ í´ë¦°', en: 'Minimal Clean' }, mood: { ko: 'ë‚®ì€ ëŒ€ë¹„ì˜ ê¹”ë”í•œ ë£©', en: 'Low-contrast clean style' }, settings: { power: 44, eye: 9, eyeSpace: 2, noseW: -4, noseH: 24, lip: 8, slim: 18, skin: 28, contour: 16, blush: 12, liner: 18, gloss: 18, hairStyle: 'none', hairColor: '#2a1b15', lipColor: '#d96f97', glasses: false, earrings: false } },
      { key: 'screen_ready', name: { ko: 'ìŠ¤í¬ë¦° ë ˆë””', en: 'Screen Ready' }, mood: { ko: 'ì¹´ë©”ë¼ ì¹œí™”í˜• ëŒ€ë¹„ ê°•í™”', en: 'Camera-friendly contrast boost' }, settings: { power: 78, eye: 26, eyeSpace: 7, noseW: -12, noseH: 58, lip: 20, slim: 38, skin: 42, contour: 42, blush: 30, liner: 60, gloss: 46, hairStyle: 'bob', hairColor: '#261814', lipColor: '#ee3f7a', glasses: false, earrings: true } }
    ];

    const I18N = {
      ko: {
        htmlLang: 'ko',
        docTitle: 'AIë·°í‹°ì‹œë®¬ë ˆì´í„° â€” ìì—°í˜• Before/After ìŠ¬ë¼ì´ë”',
        docDesc: 'ë‚´ ì–¼êµ´ ëœë“œë§ˆí¬ ê¸°ë°˜ 3D ì„±í˜• ì‹œë®¬ë ˆì´ì…˜. ëˆˆ/ì½”/ì…/ìœ¤ê³½ êµ¬ì¡° ë³€í™”ë¥¼ í˜„ì‹¤ì ìœ¼ë¡œ ë¹„êµ.',
        appTitle: 'AIë·°í‹°ì‹œë®¬ë ˆì´í„°',
        appSubtitle: 'â€” ìì—°ìŠ¤ëŸ¬ìš´ Before-After ë“œë˜ê·¸',
        topSub: 'âœ… ë¸Œë¼ìš°ì €ì—ì„œë§Œ ì²˜ë¦¬(ì„œë²„ ì—…ë¡œë“œ ì—†ìŒ) Â· âœ… ìì—°ìŠ¤ëŸ¬ìš´ AI ëœë“œë§ˆí¬ ê¸°ë°˜ ë³´ì • Â· âœ… ì°¸ê³ ìš© ì‹œë®¬ë ˆì´ì…˜',
        langLabel: 'ì–¸ì–´',
        btnCamera: 'ì¹´ë©”ë¼ ì‚¬ìš©',
        btnUpload: 'ì‚¬ì§„ ì—…ë¡œë“œ',
        btnSave: 'ì´ë¯¸ì§€ ì €ì¥',
        btnReset: 'ì´ˆê¸°í™”',
        previewTitle: 'ğŸª ë¯¸ë¦¬ë³´ê¸°',
        pillCompare: 'ìŠ¬ë¼ì´ë” ë“œë˜ê·¸ë¡œ Before/After ë¹„êµ',
        pillDepth: 'ìœ¤ê³½/ê´‘íƒì„ ê³¼í•˜ì§€ ì•Šê²Œ ë³´ì •í•´ ìì—°ìŠ¤ëŸ¬ìš´ ë³€í™”ë¥¼ ìœ ì§€',
        pillHair: 'í—¤ì–´(ì•ë¨¸ë¦¬/ë‹¨ë°œ/ì¥ë°œ) ì˜¤ë²„ë ˆì´(ë‚®ì€ ê°•ë„)',
        presetNatural: 'í”„ë¦¬ì…‹: ìì—°',
        presetDramatic: 'í”„ë¦¬ì…‹: ë“œë¼ë§ˆí‹±',
        presetGlow: 'í”„ë¦¬ì…‹: ê´‘íƒ',
        tagBefore: 'BEFORE',
        tagAfter: 'AFTER',
        tipBadge: 'íŒ',
        tipText: 'ëˆˆ/ì½”/ì…/ìœ¤ê³½ì„ ë‚®ì€ ê°•ë„ë¶€í„° ì¡°ì •í•˜ë©´ ìˆ˜ìˆ  í›„ ì¸ìƒì„ ë” í˜„ì‹¤ì ìœ¼ë¡œ ë¹„êµí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.',
        lblMirror: 'ê±°ìš¸',
        lblLandmarks: 'ëœë“œë§ˆí¬',
        lblHQ: 'ê³ í™”ì§ˆ',
        lbl3D: '3D ë Œë”',
        warnTitle: 'ë©´ì±…',
        warnBody: 'ë³¸ ì„œë¹„ìŠ¤ëŠ” ì˜¤ë½ ë° ìŠ¤íƒ€ì¼ ì°¸ê³ ìš© ì‹œë®¬ë ˆì´ì…˜ì…ë‹ˆë‹¤. ì‹¤ì œ ì‹œìˆ /ìˆ˜ìˆ  ê²°ê³¼ë¥¼ ì˜ˆì¸¡í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.',
        controlsTitle: 'ğŸ›ï¸ 3D ì„±í˜• ì‹œë®¬ë ˆì´ì…˜ ì»¨íŠ¸ë¡¤',
        controlsHint: 'ë©”ì´í¬ì—… íš¨ê³¼ ì—†ì´ ì–¼êµ´ êµ¬ì¡° ë³€í™”ë§Œ ë°˜ì˜í•´ ìˆ˜ìˆ  í›„ ì¸ìƒì„ í˜„ì‹¤ì ìœ¼ë¡œ ê°€ëŠ í•©ë‹ˆë‹¤.',
        controlNames: ['ì „ì²´ ê°•ë„', 'ëˆˆ í¬ê¸°', 'ëˆˆ ê°„ê²©', 'ì½” í­', 'ì½” â€˜ë†’ì•„ë³´ì„â€™', 'ì…ìˆ  ë³¼ë¥¨', 'í„±/ìœ¤ê³½', 'í”¼ë¶€ ë³´ì •', 'ì»¨íˆ¬ì–´(ì‰ë”©)', 'ë¸”ëŸ¬ì…”', 'ì•„ì´ë¼ì¸', 'ë¦½ ì»¬ëŸ¬', 'ë¦½ ê¸€ë¡œìŠ¤', 'í—¤ì–´ ìŠ¤íƒ€ì¼', 'í—¤ì–´ ì»¬ëŸ¬', 'ì•…ì„¸ì„œë¦¬'],
        controlDescs: ['ëª¨ë“  ë³€í˜•/ë©”ì´í¬ì—…/ìœ¤ê³½ íš¨ê³¼ì˜ â€œë§ˆìŠ¤í„° ê²Œì¸â€', 'ëˆˆ í™•ëŒ€/ì¶•ì†Œ', 'ëˆˆì„ ì•ˆ/ë°–ìœ¼ë¡œ ì´ë™', 'ì½§ë³¼ ëŠë‚Œ(ê°€ë¡œ ì›Œí”„)', 'ì½§ëŒ€ í•˜ì´ë¼ì´íŠ¸ + ì–‘ì˜† ì‰ë”© ê°•í™”', 'ì…ìˆ  í™•ëŒ€/ì¶•ì†Œ', 'ë³¼/í„± ë¼ì¸ì„ ì¤‘ì•™ìœ¼ë¡œ í•€ì¹˜(ì²´ê° í¼)', 'ì–¼êµ´ ì˜ì—­ ìŠ¤ë¬´ë”© + í†¤', 'ê´‘ëŒ€/í„±/ì½” ì˜† ì‰ë”©', 'ì¹˜í¬ ì»¬ëŸ¬', 'ìœ—ë¼ì¸/ëˆˆê¼¬ë¦¬ ê°•ì¡°', 'ì…ìˆ  ìƒ‰ìƒ', 'ì…ìˆ  ê´‘(2.5D ì²´ê°â†‘)', 'ì •ë°€ ì„¸ê·¸ë©˜í…Œì´ì…˜ ëŒ€ì‹  â€œì–¼êµ´ ì™¸ê³½/ì´ë§ˆ í¬ì¸íŠ¸â€ ê¸°ë°˜ìœ¼ë¡œ ê·¸ëŸ´ë“¯í•œ ì˜¤ë²„ë ˆì´ë¥¼ ë§Œë“­ë‹ˆë‹¤(í‹° ë§ì´ ë‚¨).', 'í—¤ì–´ ì˜¤ë²„ë ˆì´ ìƒ‰', 'ëˆˆ/í„± ìœ„ì¹˜ ê¸°ë°˜ ì˜¤ë²„ë ˆì´'],
        hairOptions: ['ì—†ìŒ', 'ì•ë¨¸ë¦¬', 'ë‹¨ë°œ(ë³´ë¸Œ)', 'ì¥ë°œ'],
        lblGlasses: 'ì•ˆê²½',
        lblEarrings: 'ê·€ê±¸ì´',
        accOn: 'ON',
        accOff: 'OFF',
        shootTipTitle: 'ì´¬ì˜ íŒ',
        shootTipBody: 'ì •ë©´ + ë°ì€ ì¡°ëª… + ì–¼êµ´ì´ í¬ê²Œ ë‚˜ì˜¤ë©´(ì´ë§ˆ~í„±) í›¨ì”¬ ìì—°ìŠ¤ëŸ½ê³  í‹°ê°€ ì˜ ë‚©ë‹ˆë‹¤.',
        hintUpload: 'ì‚¬ì§„ì„ ì—…ë¡œë“œí•˜ê±°ë‚˜ ì¹´ë©”ë¼ë¥¼ ì¼œì£¼ì„¸ìš”.',
        cameraPermission: 'ì¹´ë©”ë¼ ê¶Œí•œì„ í—ˆìš©í•´ì•¼ ì‚¬ìš©í•  ìˆ˜ ìˆì–´ìš”.'
      },
      en: {
        htmlLang: 'en',
        docTitle: 'AI Beauty Simulator â€” Dramatic Before/After Slider',
        docDesc: 'Eye/Nose/Lip/Contour warp with contour, highlight, eyeliner, lipstick, blush and hair overlays.',
        appTitle: 'AI Beauty Simulator',
        appSubtitle: 'â€” More Dramatic / Before-After Drag',
        topSub: 'âœ… In-browser only (no server upload) Â· âœ… Hair overlay + stronger contour/highlight Â· âœ… Simulation for reference',
        langLabel: 'Language',
        btnCamera: 'Use Camera',
        btnUpload: 'Upload Photo',
        btnSave: 'Save Image',
        btnReset: 'Reset',
        previewTitle: 'ğŸª Preview',
        pillCompare: 'Drag slider to compare Before/After',
        pillDepth: 'Contour pinch + highlight for a â€œ2.5Dâ€ depth illusion',
        pillHair: 'Hair overlay (bangs / bob / long)',
        presetNatural: 'Preset: Natural',
        presetDramatic: 'Preset: Dramatic',
        presetGlow: 'Preset: Glow',
        tagBefore: 'BEFORE',
        tagAfter: 'AFTER',
        tipBadge: 'Tip',
        tipText: 'Set â€œPowerâ€ to 60~80 and switch â€œHair Styleâ€ for a much stronger visible change.',
        lblMirror: 'Mirror',
        lblLandmarks: 'Landmarks',
        lblHQ: 'High Quality',
        lbl3D: '3D Render',
        warnTitle: 'Disclaimer',
        warnBody: 'This simulator is for entertainment/reference only. Actual cosmetic or styling outcomes may differ.',
        controlsTitle: 'ğŸ›ï¸ Dramatic Controls',
        controlsHint: 'This version intentionally boosts defaults for more visible changes.',
        controlNames: ['Master Power', 'Eye Size', 'Eye Spacing', 'Nose Width', 'Nose Height Look', 'Lip Volume', 'Jaw/Contour', 'Skin Smoothing', 'Contour (Shading)', 'Blush', 'Eyeliner', 'Lip Color', 'Lip Gloss', 'Hair Style', 'Hair Color', 'Accessories'],
        controlDescs: ['Master gain for all warps and makeup effects', 'Enlarge/reduce eyes', 'Move eyes inward/outward', 'Nostril width feel (horizontal warp)', 'Bridge highlight + side shading', 'Enlarge/reduce lips', 'Pinch cheek/jaw lines inward', 'Face region smoothing + tone', 'Cheek/jaw/nose-side shading', 'Cheek color', 'Upper line and tail emphasis', 'Lip color', 'Gloss highlight (2.5D boost)', 'Approximate overlay based on face outline/forehead points', 'Hair overlay color', 'Eye/jaw-based overlay accessories'],
        hairOptions: ['None', 'Bangs', 'Bob', 'Long'],
        lblGlasses: 'Glasses',
        lblEarrings: 'Earrings',
        accOn: 'ON',
        accOff: 'OFF',
        shootTipTitle: 'Capture Tip',
        shootTipBody: 'Front-facing, bright lighting, and a larger face area in frame gives better results.',
        hintUpload: 'Upload a photo or turn on the camera.',
        cameraPermission: 'Camera permission is required to use this feature.'
      },
      ja: {
        htmlLang: 'ja',
        docTitle: 'AIãƒ“ãƒ¥ãƒ¼ãƒ†ã‚£ãƒ¼ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚¿ãƒ¼ â€” Before/After ã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼',
        docDesc: 'ç›®ãƒ»é¼»ãƒ»å”‡ãƒ»è¼ªéƒ­ãƒ¯ãƒ¼ãƒ—ã¨ã€ã‚³ãƒ³ãƒˆã‚¥ã‚¢/ãƒã‚¤ãƒ©ã‚¤ãƒˆ/ã‚¢ã‚¤ãƒ©ã‚¤ãƒ³/ãƒªãƒƒãƒ—/ãƒãƒ¼ã‚¯ã€ãƒ˜ã‚¢é‡ã­åˆã‚ã›ã€‚',
        appTitle: 'AIãƒ“ãƒ¥ãƒ¼ãƒ†ã‚£ãƒ¼ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚¿ãƒ¼',
        appSubtitle: 'â€” å¤‰åŒ–ã‚’å¼·ã‚ã« / Before-After ãƒ‰ãƒ©ãƒƒã‚°',
        topSub: 'âœ… ãƒ–ãƒ©ã‚¦ã‚¶å†…å‡¦ç†ã®ã¿ï¼ˆã‚µãƒ¼ãƒãƒ¼ä¿å­˜ãªã—ï¼‰ Â· âœ… ãƒ˜ã‚¢é‡ã­åˆã‚ã› + å¼·èª¿ãƒ¡ã‚¤ã‚¯ Â· âœ… å‚è€ƒç”¨ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³',
        langLabel: 'è¨€èª',
        btnCamera: 'ã‚«ãƒ¡ãƒ©ã‚’ä½¿ã†',
        btnUpload: 'å†™çœŸã‚’ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰',
        btnSave: 'ç”»åƒã‚’ä¿å­˜',
        btnReset: 'ãƒªã‚»ãƒƒãƒˆ',
        previewTitle: 'ğŸª ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼',
        pillCompare: 'ã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼ã§ Before/After æ¯”è¼ƒ',
        pillDepth: 'è¼ªéƒ­ãƒ”ãƒ³ãƒ + ãƒã‚¤ãƒ©ã‚¤ãƒˆã§ 2.5D ç«‹ä½“æ„Ÿ',
        pillHair: 'ãƒ˜ã‚¢é‡ã­åˆã‚ã›ï¼ˆå‰é«ª / ãƒœãƒ– / ãƒ­ãƒ³ã‚°ï¼‰',
        presetNatural: 'ãƒ—ãƒªã‚»ãƒƒãƒˆ: ãƒŠãƒãƒ¥ãƒ©ãƒ«',
        presetDramatic: 'ãƒ—ãƒªã‚»ãƒƒãƒˆ: ãƒ‰ãƒ©ãƒãƒãƒƒã‚¯',
        presetGlow: 'ãƒ—ãƒªã‚»ãƒƒãƒˆ: ãƒ„ãƒ¤',
        tagBefore: 'BEFORE',
        tagAfter: 'AFTER',
        tipBadge: 'ãƒ’ãƒ³ãƒˆ',
        tipText: 'ã€Œå¼·åº¦ã€ã‚’60ã€œ80ã«ä¸Šã’ã¦ã€Œãƒ˜ã‚¢ã‚¹ã‚¿ã‚¤ãƒ«ã€ã‚’å¤‰ãˆã‚‹ã¨ã€é•ã„ãŒã‚ˆã‚Šã¯ã£ãã‚Šå‡ºã¾ã™ã€‚',
        lblMirror: 'ãƒŸãƒ©ãƒ¼',
        lblLandmarks: 'ãƒ©ãƒ³ãƒ‰ãƒãƒ¼ã‚¯',
        lblHQ: 'é«˜ç”»è³ª',
        lbl3D: '3D ãƒ¬ãƒ³ãƒ€ãƒ¼',
        warnTitle: 'å…è²¬',
        warnBody: 'æœ¬ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚¿ãƒ¼ã¯å¨¯æ¥½ãƒ»å‚è€ƒç”¨ã§ã™ã€‚å®Ÿéš›ã®æ–½è¡“/ã‚¹ã‚¿ã‚¤ãƒªãƒ³ã‚°çµæœã¨ã¯ç•°ãªã‚‹å ´åˆãŒã‚ã‚Šã¾ã™ã€‚',
        controlsTitle: 'ğŸ›ï¸ å¼·èª¿ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«',
        controlsHint: 'ä½“æ„Ÿå·®ãŒå‡ºã‚‹ã‚ˆã†ã€åŠ¹æœã‚’å¼·ã‚ã«è¨­å®šã—ã¦ã„ã¾ã™ã€‚',
        controlNames: ['å…¨ä½“å¼·åº¦', 'ç›®ã®å¤§ãã•', 'ç›®ã®é–“éš”', 'é¼»å¹…', 'é¼»ã‚’é«˜ãè¦‹ã›ã‚‹', 'å”‡ãƒœãƒªãƒ¥ãƒ¼ãƒ ', 'é¡/è¼ªéƒ­', 'è‚Œè£œæ­£', 'ã‚³ãƒ³ãƒˆã‚¥ã‚¢', 'ãƒãƒ¼ã‚¯', 'ã‚¢ã‚¤ãƒ©ã‚¤ãƒ³', 'ãƒªãƒƒãƒ—ã‚«ãƒ©ãƒ¼', 'ãƒªãƒƒãƒ—ã‚°ãƒ­ã‚¹', 'ãƒ˜ã‚¢ã‚¹ã‚¿ã‚¤ãƒ«', 'ãƒ˜ã‚¢ã‚«ãƒ©ãƒ¼', 'ã‚¢ã‚¯ã‚»ã‚µãƒªãƒ¼'],
        controlDescs: ['å…¨ä½“åŠ¹æœã®ãƒã‚¹ã‚¿ãƒ¼ã‚²ã‚¤ãƒ³', 'ç›®ã‚’æ‹¡å¤§/ç¸®å°', 'ç›®ã‚’å†…å´/å¤–å´ã«ç§»å‹•', 'å°é¼»ã®æ¨ªæ–¹å‘ãƒ¯ãƒ¼ãƒ—', 'é¼»ç­‹ãƒã‚¤ãƒ©ã‚¤ãƒˆ + ã‚µã‚¤ãƒ‰ã‚·ã‚§ãƒ¼ãƒ‰', 'å”‡ã‚’æ‹¡å¤§/ç¸®å°', 'é ¬/é¡ãƒ©ã‚¤ãƒ³ã‚’å†…å´ã«ãƒ”ãƒ³ãƒ', 'é¡”é ˜åŸŸã®ã‚¹ãƒ ãƒ¼ã‚¸ãƒ³ã‚° + ãƒˆãƒ¼ãƒ³', 'é ¬éª¨/é¡/é¼»æ¨ªã®é™°å½±', 'ãƒãƒ¼ã‚¯ã‚«ãƒ©ãƒ¼', 'ä¸Šã¾ã¶ãŸãƒ©ã‚¤ãƒ³å¼·èª¿', 'å”‡ã®è‰²', 'å”‡ã®ãƒ„ãƒ¤', 'é¡”è¼ªéƒ­/é¡ãƒã‚¤ãƒ³ãƒˆã«åŸºã¥ãé‡ã­åˆã‚ã›', 'ãƒ˜ã‚¢é‡ã­åˆã‚ã›ã®è‰²', 'ç›®/é¡ä½ç½®ãƒ™ãƒ¼ã‚¹ã®ã‚¢ã‚¯ã‚»ã‚µãƒªãƒ¼'],
        hairOptions: ['ãªã—', 'å‰é«ª', 'ãƒœãƒ–', 'ãƒ­ãƒ³ã‚°'],
        lblGlasses: 'ãƒ¡ã‚¬ãƒ',
        lblEarrings: 'ã‚¤ãƒ¤ãƒªãƒ³ã‚°',
        accOn: 'ON',
        accOff: 'OFF',
        shootTipTitle: 'æ’®å½±ã®ã‚³ãƒ„',
        shootTipBody: 'æ­£é¢ + æ˜ã‚‹ã„ç…§æ˜ + é¡”ãŒå¤§ããå†™ã‚‹æ§‹å›³ã§è‡ªç„¶ã«è¦‹ãˆã¾ã™ã€‚',
        hintUpload: 'å†™çœŸã‚’ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã™ã‚‹ã‹ã€ã‚«ãƒ¡ãƒ©ã‚’ã‚ªãƒ³ã«ã—ã¦ãã ã•ã„ã€‚',
        cameraPermission: 'ã‚«ãƒ¡ãƒ©æ¨©é™ã‚’è¨±å¯ã™ã‚‹ã¨åˆ©ç”¨ã§ãã¾ã™ã€‚'
      },
      es: {
        htmlLang: 'es',
        docTitle: 'Simulador de Belleza AI â€” Deslizador Before/After',
        docDesc: 'Warp de ojos/nariz/labios/contorno con contour, highlight, delineado, labial, rubor y peinados.',
        appTitle: 'Simulador de Belleza AI',
        appSubtitle: 'â€” MÃ¡s Notorio / Arrastrar Before-After',
        topSub: 'âœ… Solo en navegador (sin subir al servidor) Â· âœ… SuperposiciÃ³n de peinado + contour/highlight reforzado Â· âœ… SimulaciÃ³n de referencia',
        langLabel: 'Idioma',
        btnCamera: 'Usar CÃ¡mara',
        btnUpload: 'Subir Foto',
        btnSave: 'Guardar Imagen',
        btnReset: 'Reiniciar',
        previewTitle: 'ğŸª Vista previa',
        pillCompare: 'Arrastra para comparar Before/After',
        pillDepth: 'Pinch de contorno + highlight para efecto 2.5D',
        pillHair: 'SuperposiciÃ³n de cabello (flequillo / bob / largo)',
        presetNatural: 'Preset: Natural',
        presetDramatic: 'Preset: DramÃ¡tico',
        presetGlow: 'Preset: Glow',
        tagBefore: 'ANTES',
        tagAfter: 'DESPUÃ‰S',
        tipBadge: 'Tip',
        tipText: 'Sube â€œPotenciaâ€ a 60~80 y cambia â€œPeinadoâ€ para notar mÃ¡s diferencia.',
        lblMirror: 'Espejo',
        lblLandmarks: 'Puntos',
        lblHQ: 'Alta Calidad',
        lbl3D: 'Render 3D',
        warnTitle: 'Aviso',
        warnBody: 'Este simulador es solo para entretenimiento/referencia. El resultado real puede variar.',
        controlsTitle: 'ğŸ›ï¸ Controles Intensos',
        controlsHint: 'Esta versiÃ³n eleva los valores por defecto para un cambio mÃ¡s visible.',
        controlNames: ['Potencia Global', 'TamaÃ±o de Ojos', 'SeparaciÃ³n de Ojos', 'Ancho de Nariz', 'Nariz MÃ¡s Alta', 'Volumen de Labios', 'MandÃ­bula/Contorno', 'Suavizado de Piel', 'Contour (Sombra)', 'Rubor', 'Delineado', 'Color de Labios', 'Brillo de Labios', 'Peinado', 'Color de Cabello', 'Accesorios'],
        controlDescs: ['Ganancia maestra de todos los efectos', 'Aumentar/reducir ojos', 'Mover ojos hacia dentro/fuera', 'Warp horizontal de nariz', 'Highlight de puente + sombra lateral', 'Aumentar/reducir labios', 'Pinzar mejilla/mandÃ­bula al centro', 'Suavizado y tono en rostro', 'Sombra en pÃ³mulo/mandÃ­bula/nariz', 'Color de mejilla', 'Ã‰nfasis en lÃ­nea superior y cola', 'Color de labios', 'Brillo para efecto 2.5D', 'SuperposiciÃ³n aproximada por contorno facial', 'Color de superposiciÃ³n de cabello', 'Accesorios segÃºn ojos/mandÃ­bula'],
        hairOptions: ['Ninguno', 'Flequillo', 'Bob', 'Largo'],
        lblGlasses: 'Gafas',
        lblEarrings: 'Aretes',
        accOn: 'ON',
        accOff: 'OFF',
        shootTipTitle: 'Tip de Captura',
        shootTipBody: 'Frontal + buena iluminaciÃ³n + rostro grande en cuadro mejora el resultado.',
        hintUpload: 'Sube una foto o activa la cÃ¡mara.',
        cameraPermission: 'Debes permitir la cÃ¡mara para usar esta funciÃ³n.'
      },
      fr: {
        htmlLang: 'fr',
        docTitle: 'Simulateur BeautÃ© IA â€” Curseur Before/After',
        docDesc: 'Warp yeux/nez/lÃ¨vres/contour avec contouring, highlight, eyeliner, lÃ¨vres, blush et coiffures.',
        appTitle: 'Simulateur BeautÃ© IA',
        appSubtitle: 'â€” Plus marquÃ© / Glisser Before-After',
        topSub: 'âœ… Traitement local navigateur (sans upload serveur) Â· âœ… Overlay cheveux + contour/highlight renforcÃ©s Â· âœ… Simulation de rÃ©fÃ©rence',
        langLabel: 'Langue',
        btnCamera: 'Utiliser la CamÃ©ra',
        btnUpload: 'Importer une Photo',
        btnSave: 'Enregistrer lâ€™image',
        btnReset: 'RÃ©initialiser',
        previewTitle: 'ğŸª AperÃ§u',
        pillCompare: 'Glissez pour comparer Before/After',
        pillDepth: 'Pincement du contour + highlight pour effet 2.5D',
        pillHair: 'Overlay cheveux (frange / carrÃ© / long)',
        presetNatural: 'PrÃ©rÃ©glage : Naturel',
        presetDramatic: 'PrÃ©rÃ©glage : Dramatique',
        presetGlow: 'PrÃ©rÃ©glage : Glow',
        tagBefore: 'AVANT',
        tagAfter: 'APRÃˆS',
        tipBadge: 'Astuce',
        tipText: 'Montez â€œPuissanceâ€ Ã  60~80 et changez â€œStyle de cheveuxâ€ pour un effet net.',
        lblMirror: 'Miroir',
        lblLandmarks: 'RepÃ¨res',
        lblHQ: 'Haute QualitÃ©',
        lbl3D: 'Rendu 3D',
        warnTitle: 'Avertissement',
        warnBody: 'Simulateur Ã  but ludique/rÃ©fÃ©rence. Le rÃ©sultat rÃ©el peut diffÃ©rer.',
        controlsTitle: 'ğŸ›ï¸ ContrÃ´les RenforcÃ©s',
        controlsHint: 'Cette version accentue les rÃ©glages pour des changements plus visibles.',
        controlNames: ['Puissance Globale', 'Taille des Yeux', 'Ã‰cart des Yeux', 'Largeur du Nez', 'Nez Plus Haut', 'Volume des LÃ¨vres', 'MÃ¢choire/Contour', 'Lissage de la Peau', 'Contour (Ombres)', 'Blush', 'Eyeliner', 'Couleur des LÃ¨vres', 'Gloss LÃ¨vres', 'Style de Cheveux', 'Couleur des Cheveux', 'Accessoires'],
        controlDescs: ['Gain maÃ®tre de tous les effets', 'Agrandir/rÃ©duire les yeux', 'DÃ©placer les yeux dedans/dehors', 'Warp horizontal du nez', 'Highlight de lâ€™arÃªte + ombre latÃ©rale', 'Agrandir/rÃ©duire les lÃ¨vres', 'Pincer joues/mÃ¢choire vers le centre', 'Lissage + tonalitÃ© du visage', 'Ombres pommettes/mÃ¢choire/nez', 'Couleur des joues', 'Accent du trait supÃ©rieur', 'Couleur des lÃ¨vres', 'Brillance 2.5D', 'Overlay basÃ© sur contour visage/front', 'Couleur de lâ€™overlay cheveux', 'Accessoires basÃ©s yeux/mÃ¢choire'],
        hairOptions: ['Aucun', 'Frange', 'CarrÃ©', 'Long'],
        lblGlasses: 'Lunettes',
        lblEarrings: 'Boucles',
        accOn: 'ON',
        accOff: 'OFF',
        shootTipTitle: 'Conseil de Prise',
        shootTipBody: 'Face camÃ©ra + lumiÃ¨re vive + visage bien cadrÃ© donne un rendu plus naturel.',
        hintUpload: 'Importez une photo ou activez la camÃ©ra.',
        cameraPermission: 'Lâ€™autorisation camÃ©ra est nÃ©cessaire.'
      },
      de: {
        htmlLang: 'de',
        docTitle: 'AI Beauty Simulator â€” Before/After Slider',
        docDesc: 'Augen/Nase/Lippen/Kontur-Warp mit Contour, Highlight, Eyeliner, Lipcolor, Blush und Haar-Overlay.',
        appTitle: 'AI Beauty Simulator',
        appSubtitle: 'â€” Deutlicher / Before-After Ziehen',
        topSub: 'âœ… Nur im Browser (kein Server-Upload) Â· âœ… Haar-Overlay + stÃ¤rkere Kontur/Highlights Â· âœ… Referenz-Simulation',
        langLabel: 'Sprache',
        btnCamera: 'Kamera nutzen',
        btnUpload: 'Foto hochladen',
        btnSave: 'Bild speichern',
        btnReset: 'ZurÃ¼cksetzen',
        previewTitle: 'ğŸª Vorschau',
        pillCompare: 'Slider ziehen fÃ¼r Before/After',
        pillDepth: 'Kontur-Pinch + Highlight fÃ¼r 2.5D-Effekt',
        pillHair: 'Haar-Overlay (Pony / Bob / Lang)',
        presetNatural: 'Preset: NatÃ¼rlich',
        presetDramatic: 'Preset: Dramatisch',
        presetGlow: 'Preset: Glow',
        tagBefore: 'VORHER',
        tagAfter: 'NACHHER',
        tipBadge: 'Tipp',
        tipText: 'â€StÃ¤rkeâ€œ auf 60~80 erhÃ¶hen und â€Frisurâ€œ wechseln fÃ¼r klarere VerÃ¤nderung.',
        lblMirror: 'Spiegeln',
        lblLandmarks: 'Landmarks',
        lblHQ: 'Hohe QualitÃ¤t',
        lbl3D: '3D-Render',
        warnTitle: 'Hinweis',
        warnBody: 'Dieser Simulator dient nur zur Unterhaltung/Referenz. Reale Ergebnisse kÃ¶nnen abweichen.',
        controlsTitle: 'ğŸ›ï¸ Deutliche Steuerung',
        controlsHint: 'Diese Version verstÃ¤rkt Standardwerte fÃ¼r sichtbare Effekte.',
        controlNames: ['GesamtstÃ¤rke', 'AugengrÃ¶ÃŸe', 'Augenabstand', 'Nasenbreite', 'Nase hÃ¶her wirken', 'Lippenvolumen', 'Kiefer/Kontur', 'Hautkorrektur', 'Kontur (Schatten)', 'Rouge', 'Eyeliner', 'Lippenfarbe', 'Lip Gloss', 'Frisur', 'Haarfarbe', 'Accessoires'],
        controlDescs: ['Master-Gain aller Effekte', 'Augen vergrÃ¶ÃŸern/verkleinern', 'Augen nach innen/auÃŸen verschieben', 'Horizontaler Nasen-Warp', 'NasenrÃ¼cken-Highlight + Seitenschatten', 'Lippen vergrÃ¶ÃŸern/verkleinern', 'Wangen/Kiefer zur Mitte pinchen', 'GlÃ¤ttung + Hautton', 'Schatten an Wange/Kiefer/Nase', 'Wangenfarbe', 'Oberes Lid stÃ¤rker betonen', 'Farbe der Lippen', 'Lippenglanz fÃ¼r 2.5D', 'Overlay anhand Gesichtsform/Stirn', 'Farbe des Haar-Overlays', 'Overlay-Accessoires nach Augen/Kiefer'],
        hairOptions: ['Keins', 'Pony', 'Bob', 'Lang'],
        lblGlasses: 'Brille',
        lblEarrings: 'Ohrringe',
        accOn: 'ON',
        accOff: 'OFF',
        shootTipTitle: 'Aufnahme-Tipp',
        shootTipBody: 'Frontal + helles Licht + groÃŸes Gesicht im Bild verbessert das Ergebnis.',
        hintUpload: 'Foto hochladen oder Kamera einschalten.',
        cameraPermission: 'Kameraberechtigung ist erforderlich.'
      }
    };

    function tr(){
      return I18N[currentLang] || I18N.ko;
    }

    function i18nPick(obj){
      if(!obj) return '';
      return obj[currentLang] || obj.en || obj.ko || '';
    }

    function clamp(v, min, max){
      return Math.max(min, Math.min(max, v));
    }

    const LEFT_EYE_IDX = [33,133,159,145,160,158,157,173];
    const RIGHT_EYE_IDX = [362,263,386,374,385,387,384,398];
    const NOSE_IDX = [1,2,4,5,6,19,94,168,197,195,98,327];
    const LIP_IDX = [61,146,91,181,84,17,314,405,321,375,291,78,191,80,81,82,13,312,311,310,415];
    const JAW_LEFT_IDX = [172,136,150,149,176,148];
    const JAW_RIGHT_IDX = [397,365,379,378,400,377];

    let threeRenderer = null;
    let threeScene = null;
    let threeCamera = null;
    let threeMesh = null;
    let threeTexture = null;
    let triIndices = null;
    let baseUV = null;
    let threeInitialized = false;

    function ensureThree(){
      if(threeInitialized || !window.THREE || !window.Delaunator) return;
      threeRenderer = new THREE.WebGLRenderer({canvas: glC, alpha: true, antialias: true, preserveDrawingBuffer: false});
      threeRenderer.setSize(glC.width, glC.height, false);
      threeRenderer.setPixelRatio(1);
      threeRenderer.setClearColor(0x000000, 0);

      threeScene = new THREE.Scene();
      threeCamera = new THREE.PerspectiveCamera(33, glC.width / glC.height, 0.01, 20);
      threeCamera.position.set(0, 0, 2.65);
      threeScene.add(threeCamera);

      const hemi = new THREE.HemisphereLight(0xffffff, 0x1a2030, 0.95);
      threeScene.add(hemi);
      const key = new THREE.DirectionalLight(0xffffff, 0.85);
      key.position.set(0.6, 0.7, 1.2);
      threeScene.add(key);
      const fill = new THREE.DirectionalLight(0x9db4ff, 0.45);
      fill.position.set(-0.8, 0.1, 0.6);
      threeScene.add(fill);

      threeInitialized = true;
    }

    function buildFaceMesh(lm){
      ensureThree();
      if(!threeInitialized || !lm) return;
      const pts = lm.map(p => [p.x, p.y]);
      const delaunay = Delaunator.from(pts);
      triIndices = delaunay.triangles;

      const geo = new THREE.BufferGeometry();
      const pos = new Float32Array(lm.length * 3);
      baseUV = new Float32Array(lm.length * 2);
      for(let i=0;i<lm.length;i++){
        const x = (lm[i].x - 0.5) * 2.0;
        const y = -(lm[i].y - 0.5) * 2.0;
        const z = -lm[i].z * 0.9;
        pos[i*3] = x;
        pos[i*3+1] = y;
        pos[i*3+2] = z;
        baseUV[i*2] = lm[i].x;
        baseUV[i*2+1] = 1.0 - lm[i].y;
      }
      geo.setAttribute('position', new THREE.BufferAttribute(pos, 3));
      geo.setAttribute('uv', new THREE.BufferAttribute(baseUV, 2));
      geo.setIndex(new THREE.BufferAttribute(new Uint16Array(triIndices), 1));
      geo.computeVertexNormals();

      threeTexture = new THREE.CanvasTexture(src);
      threeTexture.minFilter = THREE.LinearFilter;
      threeTexture.magFilter = THREE.LinearFilter;
      threeTexture.flipY = false;

      const mat = new THREE.MeshStandardMaterial({
        map: threeTexture,
        roughness: 0.72,
        metalness: 0.02,
        transparent: true,
        opacity: 1.0,
        side: THREE.DoubleSide
      });
      threeMesh = new THREE.Mesh(geo, mat);
      threeScene.add(threeMesh);
    }

    function morph3DVertex(v, center, factor, radiusX, radiusY, sx, sy){
      const dx = v.x - center.x;
      const dy = v.y - center.y;
      const nx = dx / Math.max(1e-6, radiusX);
      const ny = dy / Math.max(1e-6, radiusY);
      const r2 = nx*nx + ny*ny;
      if(r2 > 1) return;
      const w = (1 - r2) * factor;
      v.x += dx * sx * w;
      v.y += dy * sy * w;
    }

    function shift3DVertex(v, center, factor, radiusX, radiusY, dx, dy){
      const rx = (v.x - center.x) / Math.max(1e-6, radiusX);
      const ry = (v.y - center.y) / Math.max(1e-6, radiusY);
      const r2 = rx*rx + ry*ry;
      if(r2 > 1) return;
      const w = (1 - r2) * factor;
      v.x += dx * w;
      v.y += dy * w;
    }

    function render3DFace(frameCanvas, lm, params){
      if(!chk3D.checked || !lm){
        if(glctx) glctx.clearRect(0,0,glC.width,glC.height);
        return false;
      }
      ensureThree();
      if(!threeInitialized) return false;
      if(!threeMesh || !triIndices || !baseUV) buildFaceMesh(lm);
      if(!threeMesh) return false;

      const eyeScale = params.eyeScale;
      const eyeSpaceV = params.eyeSpaceV;
      const noseWV = params.noseWV;
      const lipScale = params.lipScale;
      const slimV = params.slimV;
      const jawShapeV = params.jawShapeV || 0;
      const pwr = params.power;

      const W = glC.width;
      const H = glC.height;
      const Pt = (i)=>({x: (lm[i].x - 0.5) * 2.0, y: -(lm[i].y - 0.5) * 2.0, z: -lm[i].z * 0.9});
      const leftEyeC = avg(LEFT_EYE_IDX.map(Pt));
      const rightEyeC = avg(RIGHT_EYE_IDX.map(Pt));
      const noseC = avg(NOSE_IDX.map(Pt));
      const lipC = avg(LIP_IDX.map(Pt));
      const jawL = avg(JAW_LEFT_IDX.map(Pt));
      const jawR = avg(JAW_RIGHT_IDX.map(Pt));

      const posAttr = threeMesh.geometry.attributes.position;
      const uvAttr = threeMesh.geometry.attributes.uv;
      for(let i=0;i<lm.length;i++){
        let v = Pt(i);

        // mild localized deformation for realism
        morph3DVertex(v, leftEyeC, eyeScale*0.62, 0.20, 0.13, 1.0, 0.78);
        morph3DVertex(v, rightEyeC, eyeScale*0.62, 0.20, 0.13, 1.0, 0.78);
        shift3DVertex(v, leftEyeC, Math.abs(eyeSpaceV)*1.0, 0.24, 0.15, -eyeSpaceV*0.36, 0);
        shift3DVertex(v, rightEyeC, Math.abs(eyeSpaceV)*1.0, 0.24, 0.15, +eyeSpaceV*0.36, 0);
        morph3DVertex(v, noseC, Math.abs(noseWV)*0.78, 0.18, 0.30, noseWV*0.70, 0.0);
        morph3DVertex(v, lipC, lipScale*0.72, 0.26, 0.15, 0.95, 0.70);
        shift3DVertex(v, jawL, slimV*0.60, 0.20, 0.20, slimV*0.12, 0);
        shift3DVertex(v, jawR, slimV*0.60, 0.20, 0.20, -slimV*0.12, 0);
        shift3DVertex(v, jawL, Math.abs(jawShapeV)*0.70, 0.24, 0.20, -jawShapeV*0.12, jawShapeV*0.03);
        shift3DVertex(v, jawR, Math.abs(jawShapeV)*0.70, 0.24, 0.20, +jawShapeV*0.12, jawShapeV*0.03);
        shift3DVertex(v, lipC, Math.abs(jawShapeV)*0.35, 0.26, 0.22, 0, -jawShapeV*0.03);

        // pseudo-depth enhancement for 3D feel
        const centerBias = Math.exp(-((v.x*v.x)/0.14 + (v.y*v.y)/0.35));
        v.z -= centerBias * (0.025 + pwr*0.06);

        posAttr.array[i*3] = v.x;
        posAttr.array[i*3+1] = v.y;
        posAttr.array[i*3+2] = v.z;
        uvAttr.array[i*2] = lm[i].x;
        uvAttr.array[i*2+1] = 1.0 - lm[i].y;
      }
      posAttr.needsUpdate = true;
      uvAttr.needsUpdate = true;
      threeMesh.geometry.computeVertexNormals();

      if(threeTexture){
        threeTexture.needsUpdate = true;
      }
      threeRenderer.render(threeScene, threeCamera);
      return true;
    }

    function computeStyleScore(){
      // Style balance score: controls harmony, not attractiveness.
      const scoreParts = [
        100 - Math.min(100, Math.abs(Number(power.value) - 68) * 1.7),
        100 - Math.min(100, Math.abs(Number(eye.value) - 20) * 1.6),
        100 - Math.min(100, Math.abs(Number(eyeSpace.value) - 5) * 3.2),
        100 - Math.min(100, Math.abs(Number(noseW.value) + 10) * 2.0),
        100 - Math.min(100, Math.abs(Number(noseH.value) - 52) * 1.4),
        100 - Math.min(100, Math.abs(Number(lip.value) - 18) * 1.9),
        100 - Math.min(100, Math.abs(Number(slim.value) - 34) * 1.4),
        100 - Math.min(100, Math.abs(Number(jawShape.value) - 0) * 1.2),
        100 - Math.min(100, Math.abs(Number(contour.value) - 33) * 1.5),
        100 - Math.min(100, Math.abs(Number(gloss.value) - 44) * 1.2)
      ];
      const avgScore = scoreParts.reduce((a,b)=>a+b,0) / scoreParts.length;
      return Math.round(clamp(avgScore, 0, 100));
    }

    function applyLookSettings(settings){
      power.value = settings.power;
      eye.value = settings.eye;
      eyeSpace.value = settings.eyeSpace;
      noseW.value = settings.noseW;
      noseH.value = settings.noseH;
      lip.value = settings.lip;
      slim.value = settings.slim;
      jawShape.value = settings.jawShape ?? 0;
      skin.value = settings.skin;
      contour.value = settings.contour;
      blush.value = settings.blush;
      liner.value = settings.liner;
      gloss.value = settings.gloss;
      hairStyle.value = settings.hairStyle;
      hairColor.value = settings.hairColor;
      lipColor.value = settings.lipColor;
      glasses.checked = settings.glasses;
      earrings.checked = settings.earrings;
      setValLabels();
      renderAll();
      updateScoreUI();
    }

    function updateDeckUI(){
      if(!currentLook) return;
      lookName.textContent = `${tr().deckRecommendLabel || 'ì¶”ì²œ ë£©'}: ${i18nPick(currentLook.name)}`;
      lookMeta.textContent = i18nPick(currentLook.mood);
      lookIndex.textContent = `${lookPointer + 1} / ${LOOK_TEMPLATES.length}`;
    }

    function nextLook(){
      lookPointer = (lookPointer + 1) % LOOK_TEMPLATES.length;
      currentLook = LOOK_TEMPLATES[lookPointer];
      updateDeckUI();
    }

    function saveCurrentLook(){
      if(!currentLook) return;
      const score = computeStyleScore();
      const snapshot = {
        id: `${currentLook.key}-${Date.now()}`,
        name: i18nPick(currentLook.name),
        score,
        settings: {
          power: Number(power.value), eye: Number(eye.value), eyeSpace: Number(eyeSpace.value),
          noseW: Number(noseW.value), noseH: Number(noseH.value), lip: Number(lip.value), slim: Number(slim.value), jawShape: Number(jawShape.value),
          skin: Number(skin.value), contour: Number(contour.value), blush: Number(blush.value), liner: Number(liner.value), gloss: Number(gloss.value),
          hairStyle: hairStyle.value, hairColor: hairColor.value, lipColor: lipColor.value, glasses: glasses.checked, earrings: earrings.checked
        }
      };
      savedLooks.unshift(snapshot);
      if(savedLooks.length > 8) savedLooks.pop();
      renderSavedLooks();
    }

    function renderSavedLooks(){
      savedList.innerHTML = '';
      savedCount.textContent = `${savedLooks.length}${tr().savedCountSuffix || 'ê°œ'}`;
      if(savedLooks.length === 0){
        const empty = document.createElement('div');
        empty.className = 'savedItem';
        empty.textContent = tr().savedEmpty || 'ì €ì¥ëœ ë£©ì´ ì—†ìŠµë‹ˆë‹¤.';
        savedList.appendChild(empty);
        return;
      }
      for(const item of savedLooks){
        const row = document.createElement('div');
        row.className = 'savedItem';
        const title = document.createElement('span');
        title.textContent = `${item.name} Â· ${item.score}%`;
        const btn = document.createElement('button');
        btn.textContent = tr().applySavedBtn || 'ë‹¤ì‹œ ì ìš©';
        btn.addEventListener('click', ()=> applyLookSettings(item.settings));
        row.appendChild(title);
        row.appendChild(btn);
        savedList.appendChild(row);
      }
    }

    function updateScoreUI(){
      const score = computeStyleScore();
      scoreValue.textContent = `${score}%`;
      scoreFill.style.width = `${score}%`;
    }

    // FaceMesh init
    const faceMesh = new FaceMesh({
      locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`
    });
    faceMesh.setOptions({
      maxNumFaces: 1,
      refineLandmarks: true,
      minDetectionConfidence: 0.6,
      minTrackingConfidence: 0.6
    });
    faceMesh.onResults(onResults);

    // ----- Slider UI (Before/After split) -----
    function updateSplitUI(){
      const rect = stage.getBoundingClientRect();
      const x = rect.width * splitX;
      divider.style.left = `${x - 1.5}px`;
      handle.style.left = `${x}px`;
    }
    updateSplitUI();
    window.addEventListener('resize', ()=>{
      updateSplitUI();
      if(!usingCamera && lastFrameCanvas) renderAll();
    });

    function isMobileViewport(){
      return window.matchMedia('(max-width: 900px)').matches;
    }

    function frameIntervalMs(){
      if(!usingCamera) return 0;
      if(isMobileViewport()) return chkHQ.checked ? 95 : 150;
      return chkHQ.checked ? 36 : 68;
    }

    function applyLanguage(lang){
      if(!I18N[lang]) lang = 'ko';
      currentLang = lang;
      const text = tr();
      document.documentElement.lang = text.htmlLang;
      document.title = text.docTitle;
      const metaDesc = document.querySelector('meta[name="description"]');
      if(metaDesc) metaDesc.setAttribute('content', text.docDesc);

      $('appTitle').textContent = text.appTitle;
      $('appSubtitle').textContent = text.appSubtitle;
      $('topSub').textContent = text.topSub;
      $('lblLang').textContent = text.langLabel;
      btnUseCamera.textContent = text.btnCamera;
      $('labelUpload').textContent = text.btnUpload;
      btnSave.textContent = text.btnSave;
      btnReset.textContent = text.btnReset;
      $('previewTitle').textContent = text.previewTitle;
      $('pillCompare').textContent = text.pillCompare;
      $('pillDepth').textContent = text.pillDepth;
      $('pillHair').textContent = text.pillHair;
      btnPresetNatural.textContent = text.presetNatural;
      btnPresetDramatic.textContent = text.presetDramatic;
      btnPresetGlow.textContent = text.presetGlow;
      $('tagBefore').textContent = text.tagBefore;
      $('tagAfter').textContent = text.tagAfter;
      $('tipBadge').textContent = text.tipBadge;
      $('tipText').innerHTML = text.tipText;
      $('lblMirror').textContent = text.lblMirror;
      $('lblLandmarks').textContent = text.lblLandmarks;
      $('lblHQ').textContent = text.lblHQ;
      $('lbl3D').textContent = text.lbl3D || '3D Render';
      $('warnTitle').textContent = text.warnTitle;
      $('warnBody').textContent = text.warnBody;
      $('controlsTitle').textContent = text.controlsTitle;
      $('controlsHint').textContent = text.controlsHint;
      $('lblGlasses').textContent = text.lblGlasses;
      $('lblEarrings').textContent = text.lblEarrings;
      $('shootTipTitle').textContent = text.shootTipTitle;
      $('shootTipBody').textContent = text.shootTipBody;

      for(let i=0;i<controlNameEls.length;i++){
        if(text.controlNames[i]) controlNameEls[i].textContent = text.controlNames[i];
      }
      for(let i=0;i<controlDescEls.length;i++){
        if(text.controlDescs[i]) controlDescEls[i].textContent = text.controlDescs[i];
      }

      const hairOptions = hairStyle.querySelectorAll('option');
      text.hairOptions.forEach((name, idx)=>{
        if(hairOptions[idx]) hairOptions[idx].textContent = name;
      });

      setValLabels();
      if(!lastFrameCanvas){
        vctx.fillStyle = "rgb(9,12,26)";
        vctx.fillRect(0,0,view.width,view.height);
        drawHint(vctx, text.hintUpload);
      }
    }

    function detectLanguage(){
      const nav = (navigator.language || 'ko').toLowerCase();
      if(nav.startsWith('ko')) return 'ko';
      if(nav.startsWith('ja')) return 'ja';
      if(nav.startsWith('es')) return 'es';
      if(nav.startsWith('fr')) return 'fr';
      if(nav.startsWith('de')) return 'de';
      if(nav.startsWith('en')) return 'en';
      return 'en';
    }

    function pointerToSplit(e){
      const rect = stage.getBoundingClientRect();
      const clientX = (e.touches && e.touches[0]) ? e.touches[0].clientX : e.clientX;
      let x = (clientX - rect.left) / rect.width;
      x = Math.max(0.02, Math.min(0.98, x));
      splitX = x;
      updateSplitUI();
      composite();
    }

    stage.addEventListener('pointerdown', (e)=>{ dragging = true; stage.setPointerCapture(e.pointerId); pointerToSplit(e); });
    stage.addEventListener('pointermove', (e)=>{ if(dragging) pointerToSplit(e); });
    stage.addEventListener('pointerup', ()=> dragging = false);
    stage.addEventListener('pointercancel', ()=> dragging = false);

    stage.addEventListener('touchstart', (e)=>{ dragging = true; pointerToSplit(e); }, {passive:true});
    stage.addEventListener('touchmove', (e)=>{ if(dragging) pointerToSplit(e); }, {passive:true});
    stage.addEventListener('touchend', ()=> dragging = false);
    langSelect.addEventListener('change', ()=> applyLanguage(langSelect.value));

    // ----- UI bindings -----
    const inputs = [
      chkMirror, chkLandmarks, chkHQ, chk3D,
      power, eye, eyeSpace, noseW, noseH, lip, slim, jawShape,
      skin, contour, blush, liner, gloss,
      lipColor, hairStyle, hairColor,
      glasses, earrings
    ];
    inputs.forEach(el=>{
      el.addEventListener('input', ()=>{ setValLabels(); renderAll(); updateScoreUI(); });
      el.addEventListener('change', ()=>{ setValLabels(); renderAll(); updateScoreUI(); });
    });

    btnPresetNatural.addEventListener('click', ()=>{
      applyPreset('natural');
      renderAll();
      updateScoreUI();
    });
    btnPresetDramatic.addEventListener('click', ()=>{
      applyPreset('dramatic');
      renderAll();
      updateScoreUI();
    });
    btnPresetGlow.addEventListener('click', ()=>{
      applyPreset('glow');
      renderAll();
      updateScoreUI();
    });

    btnApplyLook.addEventListener('click', ()=>{
      if(!currentLook) return;
      applyLookSettings(currentLook.settings);
    });
    btnNextLook.addEventListener('click', ()=>{
      nextLook();
    });
    btnSaveLook.addEventListener('click', ()=>{
      saveCurrentLook();
    });

    btnUseCamera.addEventListener('click', async ()=>{
      if(usingCamera) return;
      usingCamera = true;
      await startCamera();
    });

    file.addEventListener('change', async (e)=>{
      const f = e.target.files?.[0];
      if(!f) return;

      await stopCamera();
      usingCamera = false;

      const url = URL.createObjectURL(f);
      const img = new Image();
      img.onload = async ()=>{
        drawContainToCanvas(img, sctx, src);
        await faceMesh.send({image: src});
        URL.revokeObjectURL(url);
      };
      img.src = url;
    });

    btnSave.addEventListener('click', ()=>{
      // save the composite view canvas
      const a = document.createElement('a');
      a.href = view.toDataURL('image/png');
      a.download = 'beauty-before-after.png';
      document.body.appendChild(a);
      a.click();
      a.remove();
    });

    btnReset.addEventListener('click', async ()=>{
      applyPreset('natural');
      lastLandmarks = null;
      smoothLandmarks = null;
      lastFrameCanvas = null;

      if(usingCamera) await stopCamera();
      usingCamera = false;

      // placeholder
      vctx.setTransform(1,0,0,1,0,0);
      vctx.fillStyle = "rgb(9,12,26)";
      vctx.fillRect(0,0,view.width,view.height);
      drawHint(vctx, tr().hintUpload);
      setActions(false);
      updateScoreUI();
    });

    function setActions(on){
      btnSave.disabled = !on;
      btnPresetNatural.disabled = !on;
      btnPresetDramatic.disabled = !on;
      btnPresetGlow.disabled = !on;
    }

    function setValLabels(){
      const text = tr();
      vPower.textContent = power.value;
      vEye.textContent = eye.value;
      vEyeSpace.textContent = eyeSpace.value;
      vNoseW.textContent = noseW.value;
      vNoseH.textContent = noseH.value;
      vLip.textContent = lip.value;
      vSlim.textContent = slim.value;
      vJawShape.textContent = jawShape.value;
      vSkin.textContent = skin.value;
      vContour.textContent = contour.value;
      vBlush.textContent = blush.value;
      vLiner.textContent = liner.value;
      vGloss.textContent = gloss.value;
      vLipColor.textContent = lipColor.value;
      vHairStyle.textContent = hairStyle.options[hairStyle.selectedIndex].textContent;
      vHairColor.textContent = hairColor.value;
      vAcc.textContent = (glasses.checked || earrings.checked) ? text.accOn : text.accOff;
    }

    function applyPreset(name){
      if(name === 'natural'){
        power.value = 36;
        eye.value = 8; eyeSpace.value = 2;
        noseW.value = -4; noseH.value = 24;
        lip.value = 8; slim.value = 14; jawShape.value = -6;
        skin.value = 24; contour.value = 16; blush.value = 12; liner.value = 18; gloss.value = 20;
        hairStyle.value = "none";
        glasses.checked = false; earrings.checked = false;
      }
      if(name === 'dramatic'){
        power.value = 56;
        eye.value = 15; eyeSpace.value = 4;
        noseW.value = -7; noseH.value = 38;
        lip.value = 13; slim.value = 24; jawShape.value = 8;
        skin.value = 30; contour.value = 24; blush.value = 18; liner.value = 28; gloss.value = 30;
        hairStyle.value = "bob";
        glasses.checked = false; earrings.checked = true;
      }
      if(name === 'glow'){
        power.value = 52;
        eye.value = 12; eyeSpace.value = 3;
        noseW.value = -6; noseH.value = 44;
        lip.value = 12; slim.value = 20; jawShape.value = -2;
        skin.value = 36; contour.value = 18; blush.value = 16; liner.value = 22; gloss.value = 44;
        hairStyle.value = "long";
        glasses.checked = false; earrings.checked = true;
      }
      setValLabels();
    }

    if(isMobileViewport()) chkHQ.checked = false;
    const initialLang = detectLanguage();
    langSelect.value = initialLang;
    applyLanguage(initialLang);

    // initial preset
    applyPreset('natural');
    setActions(false);
    currentLook = LOOK_TEMPLATES[lookPointer];
    updateDeckUI();
    renderSavedLooks();
    updateScoreUI();

    // placeholder
    vctx.fillStyle = "rgb(9,12,26)";
    vctx.fillRect(0,0,view.width,view.height);
    drawHint(vctx, tr().hintUpload);

    // ----- Camera -----
    async function startCamera(){
      try{
        const stream = await navigator.mediaDevices.getUserMedia({ video:{ facingMode:"user" }, audio:false });
        video.srcObject = stream;
        await video.play();

        camera = new Camera(video, {
          onFrame: async ()=>{
            const now = performance.now();
            if(now - lastProcessAt < frameIntervalMs()) return;
            lastProcessAt = now;
            drawContainToCanvas(video, sctx, src);
            await faceMesh.send({image: src});
          },
          width: 1280,
          height: 960
        });
        camera.start();
      }catch(err){
        console.error(err);
        alert(tr().cameraPermission);
        usingCamera = false;
      }
    }

    async function stopCamera(){
      if(camera){
        try{ camera.stop(); }catch{}
        camera = null;
      }
      const stream = video.srcObject;
      if(stream && stream.getTracks) stream.getTracks().forEach(t=>t.stop());
      video.srcObject = null;
    }

    // ----- FaceMesh results -----
    function onResults(results){
      const rawLm = results.multiFaceLandmarks?.[0] || null;
      lastLandmarks = stabilizeLandmarks(rawLm);
      lastFrameCanvas = src;
      setActions(true);
      renderAll();
    }

    // ----- Render pipeline -----
    function renderAll(){
      if(!lastFrameCanvas){
        vctx.setTransform(1,0,0,1,0,0);
        vctx.fillStyle = "rgb(9,12,26)";
        vctx.fillRect(0,0,view.width,view.height);
        drawHint(vctx, tr().hintUpload);
        return;
      }
      renderBefore();
      renderAfter();
      composite();
    }

    function renderBefore(){
      bctx.setTransform(1,0,0,1,0,0);
      bctx.clearRect(0,0,beforeC.width,beforeC.height);

      drawBaseFrame(bctx, lastFrameCanvas, beforeC.width, beforeC.height, chkMirror.checked);

      if(chkLandmarks.checked && lastLandmarks){
        drawLandmarks(getWorkingLandmarks(lastLandmarks, chkMirror.checked), bctx);
      }
    }

    function renderAfter(){
      actx.setTransform(1,0,0,1,0,0);
      actx.clearRect(0,0,afterC.width,afterC.height);
      drawBaseFrame(actx, lastFrameCanvas, afterC.width, afterC.height, chkMirror.checked);

      if(!lastLandmarks){
        return;
      }

      // master power
      const PWR = Number(power.value) / 100; // 0..1
      const HQ = chkHQ.checked;

      const lm = getWorkingLandmarks(lastLandmarks, chkMirror.checked);
      const W = afterC.width, H = afterC.height;
      const Pt = (i)=>({x: lm[i].x * W, y: lm[i].y * H});

      // anchors
      const leftEyeC  = avg([Pt(33), Pt(133), Pt(159), Pt(145)]);
      const rightEyeC = avg([Pt(362), Pt(263), Pt(386), Pt(374)]);
      const mouthC    = avg([Pt(13), Pt(14), Pt(78), Pt(308)]);
      const noseTip   = Pt(1);
      const noseBridge= avg([Pt(6), Pt(168), Pt(197)]);
      const chinTip   = Pt(152);

      const leftCheek  = avg([Pt(234), Pt(93), Pt(132)]);
      const rightCheek = avg([Pt(454), Pt(323), Pt(361)]);
      const leftJawMid  = Pt(172);
      const rightJawMid = Pt(397);

      // face oval mask
      const faceOvalIdx = [10,338,297,332,284,251,389,356,454,323,361,288,397,365,379,378,400,377,152,148,176,149,150,136,172,58,132,93,234,127,162,21,54,103,67,109];
      const faceOval = faceOvalIdx.map(Pt);

      // parameters (scaled by power)
      const eyeScale = (Number(eye.value)/100) * (0.20 + 0.36*PWR);
      const eyeSpaceV= (Number(eyeSpace.value)/100) * (0.16 + 0.28*PWR);

      const noseWV = (Number(noseW.value)/100) * (0.18 + 0.32*PWR);
      const noseHV = (Number(noseH.value)/100) * (0.20 + 0.40*PWR);

      const lipScale = (Number(lip.value)/100) * (0.18 + 0.34*PWR);
      const slimV = (Number(slim.value)/100) * (0.20 + 0.38*PWR);
      const jawShapeV = (Number(jawShape.value)/100) * (0.28 + 0.42*PWR);

      const contourV = (Number(slim.value)/100) * (0.20 + 0.34*PWR);
      const eyeMid = avg([leftEyeC, rightEyeC]);
      const faceYaw = clamp((noseTip.x - eyeMid.x) / Math.max(1, (rightEyeC.x - leftEyeC.x)), -0.7, 0.7);

      // 1) Geometry stage: real-time 3D mesh render (fallback: conservative 2D liquify)
      const rendered3D = render3DFace(lastFrameCanvas, lm, {
        eyeScale, eyeSpaceV, noseWV, lipScale, slimV, jawShapeV, power: PWR
      });
      if(rendered3D){
        actx.save();
        actx.globalCompositeOperation = "source-over";
        actx.globalAlpha = 1;
        actx.drawImage(glC, 0, 0, afterC.width, afterC.height);
        actx.restore();
      }else{
        applyLandmarkLiquify(actx, {
          leftEyeC, rightEyeC, mouthC, noseTip,
          leftCheek, rightCheek, leftJawMid, rightJawMid, chinTip,
          eyeScale, eyeSpaceV, noseWV, lipScale, slimV, jawShapeV, faceYaw, power: PWR
        });
      }

      // 2) structural depth cue
      if(contourV > 0.001 || noseHV > 0.001){
        applyContourHighlight(actx, {
          faceOval, noseBridge, noseTip,
          leftCheek, rightCheek, chinTip,
          contourV, noseHV, HQ
        });
      }

      // 3) pseudo-3D relighting using face orientation (depth cue boost)
      applyPseudo3DVolume(actx, {
        faceOval, leftEyeC, rightEyeC, noseBridge, noseTip, mouthC, chinTip,
        leftCheek, rightCheek, contourV, noseHV, power: PWR, yaw: faceYaw
      });

      if(chkLandmarks.checked) drawLandmarks(lm, actx);
    }

    // composite split view onto main canvas
    function composite(){
      const W = view.width, H = view.height;
      vctx.setTransform(1,0,0,1,0,0);
      vctx.clearRect(0,0,W,H);

      // Draw AFTER full, then clip BEFORE on left side (so handle shows transition)
      vctx.drawImage(afterC, 0, 0);

      const cut = Math.floor(W * splitX);
      vctx.save();
      vctx.beginPath();
      vctx.rect(0,0,cut,H);
      vctx.clip();
      vctx.drawImage(beforeC, 0, 0);
      vctx.restore();
    }

    // ----- Helpers / Effects -----
    function drawHint(ctx, text){
      const line2 = tr().shootTipBody;
      ctx.save();
      ctx.fillStyle = "rgb(9,12,26)";
      ctx.fillRect(0,0,view.width,view.height);
      ctx.fillStyle = "rgba(255,255,255,.90)";
      ctx.font = "900 28px ui-sans-serif";
      ctx.fillText(text, 48, 120);
      ctx.fillStyle = "rgba(255,255,255,.55)";
      ctx.font = "700 16px ui-sans-serif";
      ctx.fillText(line2, 48, 150);
      ctx.restore();
    }

    function drawContainToCanvas(media, ctx, canvas){
      const cw = canvas.width, ch = canvas.height;
      const mw = media.videoWidth || media.naturalWidth || media.width;
      const mh = media.videoHeight || media.naturalHeight || media.height;
      if(!mw || !mh) return;

      const scale = Math.min(cw / mw, ch / mh);
      const dw = mw * scale;
      const dh = mh * scale;
      const dx = (cw - dw) / 2;
      const dy = (ch - dh) / 2;
      ctx.setTransform(1,0,0,1,0,0);
      ctx.clearRect(0,0,cw,ch);
      ctx.drawImage(media, dx, dy, dw, dh);
    }

    function drawBaseFrame(ctx, frame, width, height, mirror){
      ctx.setTransform(1,0,0,1,0,0);
      if(mirror){
        ctx.save();
        ctx.translate(width, 0);
        ctx.scale(-1, 1);
        ctx.drawImage(frame, 0, 0, width, height);
        ctx.restore();
      }else{
        ctx.drawImage(frame, 0, 0, width, height);
      }
    }

    function getWorkingLandmarks(lm, mirror){
      if(!mirror || !lm) return lm;
      const out = new Array(lm.length);
      for(let i=0;i<lm.length;i++){
        out[i] = {x: 1 - lm[i].x, y: lm[i].y, z: lm[i].z};
      }
      return out;
    }

    function stabilizeLandmarks(rawLm){
      if(!rawLm){
        smoothLandmarks = null;
        return null;
      }
      if(!smoothLandmarks || smoothLandmarks.length !== rawLm.length){
        smoothLandmarks = rawLm.map(p => ({x:p.x, y:p.y, z:p.z || 0}));
        return smoothLandmarks.map(p => ({x:p.x, y:p.y, z:p.z}));
      }
      const blend = 0.42; // lower = smoother, higher = faster response
      const maxDelta = 0.028;
      for(let i=0;i<rawLm.length;i++){
        const prev = smoothLandmarks[i];
        const nx = prev.x + (rawLm[i].x - prev.x) * blend;
        const ny = prev.y + (rawLm[i].y - prev.y) * blend;
        const nz = prev.z + ((rawLm[i].z || 0) - (prev.z || 0)) * blend;
        prev.x += clamp(nx - prev.x, -maxDelta, maxDelta);
        prev.y += clamp(ny - prev.y, -maxDelta, maxDelta);
        prev.z += clamp(nz - prev.z, -maxDelta, maxDelta);
      }
      return smoothLandmarks.map(p => ({x:p.x, y:p.y, z:p.z}));
    }

    function applyLandmarkLiquify(ctx, cfg){
      // Conservative landmark warp to preserve identity.
      const {
        leftEyeC, rightEyeC, mouthC, noseTip,
        leftCheek, rightCheek, leftJawMid, rightJawMid, chinTip,
        eyeScale, eyeSpaceV, noseWV, lipScale, slimV, jawShapeV=0, faceYaw=0, power=0.5
      } = cfg;

      const base = 0.75 + power*0.20;
      const eyeGain = eyeScale * 0.24 * base;
      const leftWeight = clamp(1 - faceYaw*0.35, 0.72, 1.20);
      const rightWeight = clamp(1 + faceYaw*0.35, 0.72, 1.20);
      if(Math.abs(eyeSpaceV) > 0.0005){
        shiftRegion(ctx, leftEyeC, 150, 110, -eyeSpaceV*16);
        shiftRegion(ctx, rightEyeC, 150, 110, +eyeSpaceV*16);
      }
      if(Math.abs(eyeGain) > 0.0005){
        regionScale(ctx, leftEyeC, 150, 110, 1 + eyeGain*leftWeight, 1 + eyeGain*0.40*leftWeight);
        regionScale(ctx, rightEyeC, 150, 110, 1 + eyeGain*rightWeight, 1 + eyeGain*0.40*rightWeight);
      }

      if(Math.abs(noseWV) > 0.0005){
        regionScale(ctx, noseTip, 150, 210, 1 + (noseWV*0.40*base), 1);
      }

      if(Math.abs(lipScale) > 0.0005){
        regionScale(ctx, mouthC, 210, 125, 1 + (lipScale*0.30*base), 1 + (lipScale*0.20*base));
      }

      if(Math.abs(slimV) > 0.0005){
        softPinch(ctx, leftCheek,   170, 210, slimV*0.11*leftWeight, +1, false);
        softPinch(ctx, rightCheek,  170, 210, slimV*0.11*rightWeight, -1, false);
        softPinch(ctx, leftJawMid,  150, 180, slimV*0.12*leftWeight, +1, false);
        softPinch(ctx, rightJawMid, 150, 180, slimV*0.12*rightWeight, -1, false);
        softPinch(ctx, chinTip, 190, 150, slimV*0.06*base, 0, false);
      }
      if(Math.abs(jawShapeV) > 0.0005){
        shiftRegion(ctx, leftJawMid, 130, 120, -jawShapeV*20);
        shiftRegion(ctx, rightJawMid, 130, 120, +jawShapeV*20);
      }
    }

    function applyPseudo3DVolume(ctx, cfg){
      const {faceOval, leftEyeC, rightEyeC, noseBridge, noseTip, mouthC, chinTip, leftCheek, rightCheek, contourV, noseHV, power, yaw} = cfg;
      const W = ctx.canvas.width;
      const lightX = yaw >= 0 ? -1 : 1; // opposite side gets softer light
      const lightBias = 0.5 + Math.abs(yaw)*0.6;

      ctx.save();
      polygonClip(ctx, faceOval);

      // Soft global relight: highlight forehead/bridge and subtle chin/cheek occlusion.
      const bridgeAlpha = (0.06 + noseHV*0.14) * (0.8 + power*0.5);
      ctx.globalAlpha = bridgeAlpha;
      radialGlow(ctx, noseBridge.x - 14*lightX, noseBridge.y - 26, 130, "rgba(255,255,255,0.26)");
      radialGlow(ctx, noseTip.x - 7*lightX, noseTip.y - 4, 80, "rgba(255,255,255,0.20)");

      const cheekShadow = (0.05 + contourV*0.12) * (0.7 + lightBias*0.4);
      ctx.globalAlpha = cheekShadow;
      radialGlow(ctx, leftCheek.x - 44, leftCheek.y + 28, 180, "rgba(22,13,16,0.42)");
      radialGlow(ctx, rightCheek.x + 44, rightCheek.y + 28, 180, "rgba(22,13,16,0.42)");

      ctx.globalAlpha = 0.05 + contourV*0.10;
      radialGlow(ctx, chinTip.x, chinTip.y + 30, 170, "rgba(28,16,20,0.40)");

      // Eye socket depth and philtrum highlight increase 3D perception without changing identity.
      ctx.globalAlpha = 0.04 + contourV*0.08;
      radialGlow(ctx, leftEyeC.x, leftEyeC.y + 16, 90, "rgba(20,12,15,0.35)");
      radialGlow(ctx, rightEyeC.x, rightEyeC.y + 16, 90, "rgba(20,12,15,0.35)");

      ctx.globalAlpha = 0.05 + noseHV*0.12;
      radialGlow(ctx, mouthC.x, mouthC.y - 18, 70, "rgba(255,255,255,0.18)");

      ctx.restore();
      ctx.globalAlpha = 1;
    }

    function avg(points){
      let x=0,y=0;
      for(const p of points){ x+=p.x; y+=p.y; }
      return {x:x/points.length, y:y/points.length};
    }

    function drawLandmarks(lm, ctx){
      const W = ctx.canvas.width, H = ctx.canvas.height;
      ctx.save();
      ctx.globalAlpha = 0.75;
      ctx.fillStyle = "rgba(255,211,110,.9)";
      for(let i=0;i<lm.length;i++){
        const x = lm[i].x*W, y = lm[i].y*H;
        ctx.fillRect(x-1, y-1, 2, 2);
      }
      ctx.restore();
    }

    function polygonClip(ctx, poly){
      ctx.beginPath();
      ctx.moveTo(poly[0].x, poly[0].y);
      for(let i=1;i<poly.length;i++) ctx.lineTo(poly[i].x, poly[i].y);
      ctx.closePath();
      ctx.clip();
    }
    function polygonFill(ctx, poly){
      ctx.beginPath();
      ctx.moveTo(poly[0].x, poly[0].y);
      for(let i=1;i<poly.length;i++) ctx.lineTo(poly[i].x, poly[i].y);
      ctx.closePath();
      ctx.fill();
    }

    function regionScale(ctx, center, w, h, sx, sy){
      const x = Math.round(center.x - w/2);
      const y = Math.round(center.y - h/2);
      const tw = Math.round(w);
      const th = Math.round(h);

      const tmp = document.createElement('canvas');
      tmp.width = tw; tmp.height = th;
      tmp.getContext('2d').drawImage(ctx.canvas, x, y, tw, th, 0, 0, tw, th);

      ctx.save();
      ctx.beginPath();
      ctx.ellipse(center.x, center.y, w*0.49, h*0.49, 0, 0, Math.PI*2);
      ctx.clip();

      const dw = tw*sx, dh = th*sy;
      ctx.drawImage(tmp, center.x - dw/2, center.y - dh/2, dw, dh);

      ctx.restore();
    }

    function shiftRegion(ctx, center, w, h, dx){
      const x = Math.round(center.x - w/2);
      const y = Math.round(center.y - h/2);
      const tw = Math.round(w);
      const th = Math.round(h);

      const tmp = document.createElement('canvas');
      tmp.width = tw; tmp.height = th;
      tmp.getContext('2d').drawImage(ctx.canvas, x, y, tw, th, 0, 0, tw, th);

      ctx.save();
      ctx.beginPath();
      ctx.ellipse(center.x, center.y, w*0.49, h*0.49, 0, 0, Math.PI*2);
      ctx.clip();

      ctx.drawImage(tmp, x + dx, y, tw, th);
      ctx.restore();
    }

    // softPinch: sliced warp; dir=+1 inward right, -1 inward left, 0 symmetric inward to center
    function softPinch(ctx, center, w, h, strength, dir, HQ){
      const x = Math.round(center.x - w/2);
      const y = Math.round(center.y - h/2);
      const tw = Math.round(w);
      const th = Math.round(h);

      const tmp = document.createElement('canvas');
      tmp.width = tw; tmp.height = th;
      tmp.getContext('2d').drawImage(ctx.canvas, x, y, tw, th, 0, 0, tw, th);

      const slices = HQ ? 34 : 24;
      const sliceW = Math.max(2, Math.floor(tw / slices));
      const maxShift = strength * 0.14 * tw;

      ctx.save();
      ctx.beginPath();
      ctx.ellipse(center.x, center.y, w*0.49, h*0.49, 0, 0, Math.PI*2);
      ctx.clip();

      for(let i=0;i<slices;i++){
        const sx = i*sliceW;
        const sw = (i===slices-1) ? (tw - sx) : sliceW;

        const t = i/(slices-1); // 0..1 across region

        let edge;
        if(dir === +1) edge = (1 - t);          // outer edge on left
        else if(dir === -1) edge = t;           // outer edge on right
        else edge = Math.abs(t - 0.5) * 2;      // both edges
        const wgt = Math.pow(edge, 1.55);

        let shift = maxShift * wgt;
        if(dir === +1) shift = +shift;
        else if(dir === -1) shift = -shift;
        else shift = (t<0.5) ? +shift : -shift; // symmetric toward center

        ctx.drawImage(tmp, sx, 0, sw, th, x + sx + shift, y, sw, th);
      }
      ctx.restore();
    }

    function applySkin(ctx, facePoly, amount, HQ){
      const passes = HQ ? Math.round(2 + amount*5) : Math.round(2 + amount*3);
      const alpha = HQ ? (0.03 + amount*0.08) : (0.028 + amount*0.06);

      ctx.save();
      polygonClip(ctx, facePoly);

      ctx.globalAlpha = alpha;
      for(let i=0;i<passes;i++){
        const s = 1 + (i+1) * (HQ ? 0.0035 : 0.0023) * amount;
        ctx.save();
        ctx.translate(ctx.canvas.width/2, ctx.canvas.height/2);
        ctx.scale(s, s);
        ctx.translate(-ctx.canvas.width/2, -ctx.canvas.height/2);
        ctx.drawImage(ctx.canvas, 0, 0);
        ctx.restore();
      }

      // tone lift + tiny highlight
      ctx.globalAlpha = 0.04 + amount*0.10;
      ctx.fillStyle = "rgba(255,235,240,0.35)";
      ctx.fillRect(0,0,ctx.canvas.width, ctx.canvas.height);

      ctx.globalAlpha = 0.03 + amount*0.06;
      ctx.fillStyle = "rgba(255,255,255,0.20)";
      ctx.fillRect(0,0,ctx.canvas.width, ctx.canvas.height);

      ctx.restore();
      ctx.globalAlpha = 1;
    }

    function radialGlow(ctx, x, y, r, color){
      const g = ctx.createRadialGradient(x,y, 0, x,y, r);
      g.addColorStop(0, color);
      g.addColorStop(1, "rgba(0,0,0,0)");
      ctx.fillStyle = g;
      ctx.beginPath();
      ctx.arc(x,y,r,0,Math.PI*2);
      ctx.fill();
    }

    function applyContourHighlight(ctx, cfg){
      const {faceOval, noseBridge, noseTip, leftCheek, rightCheek, chinTip, contourV, noseHV, HQ} = cfg;

      ctx.save();
      polygonClip(ctx, faceOval);

      // contour
      if(contourV > 0.001){
        const a = contourV * (HQ ? 0.16 : 0.12);
        ctx.globalAlpha = a;

        radialGlow(ctx, leftCheek.x - 160, leftCheek.y + 140, HQ ? 320 : 260, "rgba(35,15,20,0.55)");
        radialGlow(ctx, rightCheek.x + 160, rightCheek.y + 140, HQ ? 320 : 260, "rgba(35,15,20,0.55)");

        radialGlow(ctx, leftCheek.x - 70, leftCheek.y + 40, HQ ? 260 : 220, "rgba(45,18,22,0.45)");
        radialGlow(ctx, rightCheek.x + 70, rightCheek.y + 40, HQ ? 260 : 220, "rgba(45,18,22,0.45)");

        radialGlow(ctx, chinTip.x, chinTip.y + 70, HQ ? 280 : 240, "rgba(40,18,22,0.55)");
        ctx.globalAlpha = 1;
      }

      // nose height (highlight + side shading)
      if(noseHV > 0.001){
        const a = noseHV * (HQ ? 0.22 : 0.16);
        ctx.globalAlpha = a;

        const g = ctx.createLinearGradient(noseBridge.x, noseBridge.y - 140, noseTip.x, noseTip.y + 160);
        g.addColorStop(0, "rgba(255,255,255,0.00)");
        g.addColorStop(0.35, "rgba(255,255,255,0.55)");
        g.addColorStop(0.65, "rgba(255,255,255,0.28)");
        g.addColorStop(1, "rgba(255,255,255,0.00)");
        ctx.fillStyle = g;
        roundRectFill(ctx, noseBridge.x - 18, noseBridge.y - 110, 36, 280, 18);

        // side shadows
        ctx.globalAlpha = a*0.62;
        radialGlow(ctx, noseTip.x - 48, noseTip.y + 22, HQ ? 150 : 130, "rgba(35,14,18,0.55)");
        radialGlow(ctx, noseTip.x + 48, noseTip.y + 22, HQ ? 150 : 130, "rgba(35,14,18,0.55)");

        // tip highlight
        ctx.globalAlpha = a*0.62;
        radialGlow(ctx, noseTip.x, noseTip.y + 12, HQ ? 105 : 90, "rgba(255,255,255,0.35)");

        ctx.globalAlpha = 1;
      }

      // cheekbone highlight (2.5D pop)
      ctx.globalAlpha = (HQ ? 0.06 : 0.045) * (0.6 + contourV);
      radialGlow(ctx, leftCheek.x - 20, leftCheek.y - 10, HQ ? 230 : 190, "rgba(255,255,255,0.20)");
      radialGlow(ctx, rightCheek.x + 20, rightCheek.y - 10, HQ ? 230 : 190, "rgba(255,255,255,0.20)");
      ctx.globalAlpha = 1;

      ctx.restore();
    }

    function applyBlush(ctx, leftCheek, rightCheek, amount, HQ){
      const a = amount * (HQ ? 0.20 : 0.16);
      ctx.save();
      ctx.globalAlpha = a;
      radialGlow(ctx, leftCheek.x - 18, leftCheek.y + 30, HQ ? 190 : 160, "rgba(255,80,120,0.55)");
      radialGlow(ctx, rightCheek.x + 18, rightCheek.y + 30, HQ ? 190 : 160, "rgba(255,80,120,0.55)");
      ctx.restore();
    }

    function applyEyeliner(ctx, lm, amount){
      const W = ctx.canvas.width, H = ctx.canvas.height;
      const a = amount; // already 0..1
      if(a <= 0.001) return;

      const P = (i)=>({x: lm[i].x*W, y: lm[i].y*H});
      const leftUpper  = [33, 160, 158, 157, 173, 133];
      const rightUpper = [362, 385, 387, 386, 384, 263];

      ctx.save();
      ctx.globalAlpha = 0.08 + a*0.36;
      ctx.strokeStyle = "rgba(8,8,12,0.95)";
      ctx.lineWidth = 2.2 + a*3.2;
      ctx.lineCap = "round";
      ctx.lineJoin = "round";

      strokePath(leftUpper.map(P));
      strokePath(rightUpper.map(P));

      // wing
      ctx.globalAlpha = 0.06 + a*0.30;
      wing(P(33), P(133), +1);
      wing(P(362), P(263), -1);

      ctx.restore();

      function strokePath(pts){
        ctx.beginPath();
        ctx.moveTo(pts[0].x, pts[0].y);
        for(let i=1;i<pts.length;i++) ctx.lineTo(pts[i].x, pts[i].y);
        ctx.stroke();
      }
      function wing(outer, inner, dir){
        const dx = outer.x - inner.x;
        const dy = outer.y - inner.y;
        const len = Math.hypot(dx,dy) || 1;
        const nx = (dx/len), ny = (dy/len);
        const wx = outer.x + nx*18 + dir*4;
        const wy = outer.y + ny*10 - 6;
        ctx.beginPath();
        ctx.moveTo(outer.x, outer.y);
        ctx.lineTo(wx, wy);
        ctx.stroke();
      }
    }

    function applyLips(ctx, lm, hex, strength, glossAmount, HQ){
      const W = ctx.canvas.width, H = ctx.canvas.height;
      const P = (i)=>({x: lm[i].x*W, y: lm[i].y*H});

      const lipOuter = [61,185,40,39,37,0,267,269,270,409,291,375,321,405,314,17,84,181,91,146];
      const poly = lipOuter.map(P);

      ctx.save();

      // base fill
      ctx.globalAlpha = clamp01(strength);
      ctx.fillStyle = hexToRgba(hex, 0.90);
      polygonFill(ctx, poly);

      // soften edges
      ctx.globalAlpha = (HQ ? 0.16 : 0.12) + 0.20*clamp01(strength);
      ctx.filter = `blur(${HQ ? 1.6 : 1.1}px)`;
      polygonFill(ctx, poly);
      ctx.filter = "none";

      // inner gradient for â€œ3D lipâ€
      ctx.globalAlpha = 0.16 + 0.28*clamp01(strength);
      const m = avg([P(13), P(14), P(78), P(308)]);
      radialGlow(ctx, m.x, m.y + 18, HQ ? 150 : 120, "rgba(255,255,255,0.18)");

      // gloss highlight
      if(glossAmount > 0.001){
        ctx.globalAlpha = glossAmount * (HQ ? 0.45 : 0.34);
        const topC = avg([P(13), P(0), P(267)]);
        radialGlow(ctx, topC.x, topC.y + 10, HQ ? 140 : 110, "rgba(255,255,255,0.38)");
      }

      ctx.restore();
    }

    function clamp01(x){ return Math.max(0, Math.min(1, x)); }
    function hexToRgba(hex, a){
      const h = hex.replace('#','').trim();
      const r = parseInt(h.substring(0,2), 16);
      const g = parseInt(h.substring(2,4), 16);
      const b = parseInt(h.substring(4,6), 16);
      return `rgba(${r},${g},${b},${a})`;
    }
    function roundRectFill(ctx, x, y, w, h, r){
      ctx.beginPath();
      ctx.moveTo(x+r,y);
      ctx.arcTo(x+w,y,x+w,y+h,r);
      ctx.arcTo(x+w,y+h,x,y+h,r);
      ctx.arcTo(x,y+h,x,y,r);
      ctx.arcTo(x,y,x+w,y,r);
      ctx.closePath();
      ctx.fill();
    }

    // ----- Hair overlay (big visual change) -----
    function drawHairOverlay(ctx, lm, style, colorHex, HQ, power=0.5){
      const W = ctx.canvas.width, H = ctx.canvas.height;
      const P = (i)=>({x: lm[i].x*W, y: lm[i].y*H});

      // face oval points
      const faceIdx = [10,338,297,332,284,251,389,356,454,323,361,288,397,365,379,378,400,377,152,148,176,149,150,136,172,58,132,93,234,127,162,21,54,103,67,109];
      const face = faceIdx.map(P);

      // key points
      const forehead = P(10);
      const chin = P(152);
      const leftTemple = P(109);
      const rightTemple = P(338);
      const leftJaw = P(234);
      const rightJaw = P(454);

      // approximate head box
      const faceBox = bounds(face);
      const headTopY = Math.max(0, faceBox.yMin - (faceBox.h * 0.55));
      const headW = faceBox.w * 1.35;
      const headX = faceBox.cx - headW/2;

      ctx.save();

      // shadow behind hair for depth
      ctx.globalAlpha = HQ ? 0.12 : 0.10;
      ctx.filter = `blur(${HQ ? 6 : 4}px)`;
      ctx.fillStyle = "rgba(0,0,0,0.55)";
      ctx.beginPath();
      ctx.ellipse(faceBox.cx, faceBox.yMin + faceBox.h*0.25, headW*0.50, faceBox.h*0.70, 0, 0, Math.PI*2);
      ctx.fill();
      ctx.filter = "none";

      // hair base gradient
      const base = ctx.createLinearGradient(0, headTopY, 0, faceBox.yMax + faceBox.h*0.35);
      base.addColorStop(0, hexToRgba(colorHex, 0.78));
      base.addColorStop(0.6, hexToRgba(colorHex, 0.64));
      base.addColorStop(1, "rgba(0,0,0,0.35)");

      // hair shape depending on style
      ctx.globalAlpha = 0.34 + power*0.28;
      ctx.fillStyle = base;

      if(style === 'bangs'){
        // cap + bangs
        hairCap(ctx, headX, headTopY, headW, faceBox.h*0.95, 0.52);
        // bangs: multiple strands across forehead
        bangs(ctx, leftTemple, rightTemple, forehead, faceBox.h*0.20);
      } else if(style === 'bob'){
        // bob: cap + rounded sides down to jaw
        hairCap(ctx, headX, headTopY, headW, faceBox.h*0.95, 0.55);
        bobSides(ctx, leftJaw, rightJaw, chin, faceBox.h*0.15);
      } else if(style === 'long'){
        // long: cap + long drapes
        hairCap(ctx, headX, headTopY, headW, faceBox.h*1.10, 0.58);
        longDrape(ctx, leftTemple, rightTemple, chin, faceBox.h*0.55);
        bangs(ctx, leftTemple, rightTemple, forehead, faceBox.h*0.12); // light bangs for realism
      }

      // hair shine (adds 3D feel)
      ctx.globalAlpha = HQ ? 0.10 : 0.08;
      ctx.filter = `blur(${HQ ? 8 : 6}px)`;
      const shine = ctx.createLinearGradient(faceBox.cx - headW*0.25, headTopY, faceBox.cx + headW*0.15, headTopY + faceBox.h);
      shine.addColorStop(0, "rgba(255,255,255,0.00)");
      shine.addColorStop(0.4, "rgba(255,255,255,0.22)");
      shine.addColorStop(0.8, "rgba(255,255,255,0.02)");
      ctx.fillStyle = shine;
      ctx.beginPath();
      ctx.ellipse(faceBox.cx - headW*0.10, headTopY + faceBox.h*0.35, headW*0.22, faceBox.h*0.45, -0.12, 0, Math.PI*2);
      ctx.fill();
      ctx.filter = "none";

      // clip hair so it doesnâ€™t paint over face too much: subtract face area a little (soft)
      ctx.globalCompositeOperation = "destination-out";
      ctx.globalAlpha = 0.34;
      ctx.filter = `blur(${HQ ? 10 : 7}px)`;
      polygonFill(ctx, face);
      ctx.filter = "none";
      ctx.globalCompositeOperation = "source-over";

      ctx.restore();

      function hairCap(ctx, x, y, w, h, round){
        ctx.beginPath();
        ctx.moveTo(x + w*0.10, y + h*0.35);
        ctx.bezierCurveTo(x + w*0.18, y + h*0.05, x + w*0.82, y + h*0.05, x + w*0.90, y + h*0.35);
        ctx.bezierCurveTo(x + w*0.98, y + h*(0.70+round*0.12), x + w*0.70, y + h*0.95, x + w*0.50, y + h*0.98);
        ctx.bezierCurveTo(x + w*0.30, y + h*0.95, x + w*0.02, y + h*(0.70+round*0.12), x + w*0.10, y + h*0.35);
        ctx.closePath();
        ctx.fill();
      }

      function bangs(ctx, L, R, F, depth){
        const topY = Math.min(L.y, R.y, F.y) + depth*0.10;
        const bottomY = F.y + depth*0.55;
        const leftX = L.x - (R.x-L.x)*0.06;
        const rightX = R.x + (R.x-L.x)*0.06;

        // main bangs mass
        ctx.beginPath();
        ctx.moveTo(leftX, topY);
        ctx.bezierCurveTo(leftX + (rightX-leftX)*0.25, bottomY - depth*0.55, rightX - (rightX-leftX)*0.25, bottomY - depth*0.55, rightX, topY);
        ctx.bezierCurveTo(rightX - (rightX-leftX)*0.10, bottomY + depth*0.15, leftX + (rightX-leftX)*0.10, bottomY + depth*0.15, leftX, topY);
        ctx.closePath();
        ctx.fill();

        // strands (more â€œí‹°â€)
        ctx.save();
        ctx.globalAlpha *= 0.35;
        ctx.strokeStyle = "rgba(0,0,0,0.28)";
        ctx.lineWidth = 2;
        for(let i=0;i<9;i++){
          const t = i/8;
          const x = leftX*(1-t) + rightX*t;
          ctx.beginPath();
          ctx.moveTo(x, topY);
          ctx.quadraticCurveTo(x + (Math.random()*12-6), bottomY, x + (Math.random()*18-9), bottomY + depth*0.12);
          ctx.stroke();
        }
        ctx.restore();
      }

      function bobSides(ctx, LJ, RJ, chin, extra){
        const y1 = Math.min(LJ.y, RJ.y) - extra*0.25;
        const y2 = chin.y + extra*0.10;

        // left side
        ctx.beginPath();
        ctx.moveTo(LJ.x - 60, y1);
        ctx.quadraticCurveTo(LJ.x - 120, (y1+y2)/2, LJ.x - 40, y2);
        ctx.quadraticCurveTo(LJ.x + 10, y2 - 10, LJ.x - 10, y1 + 40);
        ctx.closePath();
        ctx.fill();

        // right side
        ctx.beginPath();
        ctx.moveTo(RJ.x + 60, y1);
        ctx.quadraticCurveTo(RJ.x + 120, (y1+y2)/2, RJ.x + 40, y2);
        ctx.quadraticCurveTo(RJ.x - 10, y2 - 10, RJ.x + 10, y1 + 40);
        ctx.closePath();
        ctx.fill();
      }

      function longDrape(ctx, L, R, chin, len){
        const yTop = Math.min(L.y, R.y) - 30;
        const yBot = chin.y + len;

        // left drape
        ctx.beginPath();
        ctx.moveTo(L.x - 40, yTop);
        ctx.bezierCurveTo(L.x - 200, yTop + len*0.25, L.x - 180, yBot - len*0.15, L.x - 70, yBot);
        ctx.bezierCurveTo(L.x - 20, yBot - 20, L.x + 40, yTop + 80, L.x - 40, yTop);
        ctx.closePath();
        ctx.fill();

        // right drape
        ctx.beginPath();
        ctx.moveTo(R.x + 40, yTop);
        ctx.bezierCurveTo(R.x + 200, yTop + len*0.25, R.x + 180, yBot - len*0.15, R.x + 70, yBot);
        ctx.bezierCurveTo(R.x + 20, yBot - 20, R.x - 40, yTop + 80, R.x + 40, yTop);
        ctx.closePath();
        ctx.fill();
      }

      function bounds(pts){
        let xMin=1e9,yMin=1e9,xMax=-1e9,yMax=-1e9;
        for(const p of pts){
          xMin = Math.min(xMin, p.x);
          yMin = Math.min(yMin, p.y);
          xMax = Math.max(xMax, p.x);
          yMax = Math.max(yMax, p.y);
        }
        const w = xMax-xMin, h=yMax-yMin;
        return {xMin,yMin,xMax,yMax,w,h,cx:(xMin+xMax)/2, cy:(yMin+yMax)/2};
      }
    }

    // ----- Accessories -----
    function drawGlasses(ctx, leftEye, rightEye){
      const dx = rightEye.x - leftEye.x;
      const dy = rightEye.y - leftEye.y;
      const dist = Math.hypot(dx, dy);
      const angle = Math.atan2(dy, dx);

      const frameW = dist * 2.20;
      const frameH = dist * 0.75;
      const bridgeW = dist * 0.22;

      ctx.save();
      ctx.translate((leftEye.x + rightEye.x)/2, (leftEye.y + rightEye.y)/2);
      ctx.rotate(angle);
      ctx.globalAlpha = 0.92;

      const lw = Math.max(2.5, dist*0.05);
      ctx.lineWidth = lw;
      ctx.strokeStyle = "rgba(255,255,255,.86)";
      ctx.fillStyle = "rgba(0,0,0,.12)";

      const lensW = (frameW - bridgeW) / 2;
      const lensH = frameH;

      rr(-frameW/2, -lensH/2, lensW, lensH, lensH*0.28); ctx.fill(); ctx.stroke();
      rr(frameW/2 - lensW, -lensH/2, lensW, lensH, lensH*0.28); ctx.fill(); ctx.stroke();

      ctx.beginPath(); ctx.moveTo(-bridgeW/2, 0); ctx.lineTo(bridgeW/2, 0); ctx.stroke();

      ctx.globalAlpha = 0.78;
      ctx.beginPath();
      ctx.moveTo(-frameW/2, -lensH*0.06); ctx.lineTo(-frameW/2 - dist*0.65, -lensH*0.20);
      ctx.moveTo(frameW/2, -lensH*0.06);  ctx.lineTo(frameW/2 + dist*0.65, -lensH*0.20);
      ctx.stroke();

      ctx.restore();

      function rr(x,y,w,h,r){
        ctx.beginPath();
        ctx.moveTo(x+r,y);
        ctx.arcTo(x+w,y,x+w,y+h,r);
        ctx.arcTo(x+w,y+h,x,y+h,r);
        ctx.arcTo(x,y+h,x,y,r);
        ctx.arcTo(x,y,x+w,y,r);
        ctx.closePath();
      }
    }

    function drawEarrings(ctx, leftJaw, rightJaw, HQ){
      ctx.save();
      ctx.globalAlpha = 0.90;
      const r = ctx.canvas.width * 0.0068;

      const g = ctx.createLinearGradient(0,0,0, ctx.canvas.height);
      g.addColorStop(0, "rgba(255,226,140,.95)");
      g.addColorStop(1, "rgba(255,170,90,.85)");
      ctx.fillStyle = g;
      ctx.strokeStyle = "rgba(255,255,255,.25)";
      ctx.lineWidth = 2;

      drop(leftJaw.x, leftJaw.y + ctx.canvas.height*0.035);
      drop(rightJaw.x, rightJaw.y + ctx.canvas.height*0.035);

      ctx.restore();

      function drop(x,y){
        ctx.beginPath(); ctx.arc(x, y, r, 0, Math.PI*2); ctx.fill(); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(x, y+r); ctx.lineTo(x, y+r*(HQ?6.4:6.0)); ctx.stroke();
        ctx.beginPath(); ctx.arc(x, y+r*(HQ?7.9:7.3), r*1.35, 0, Math.PI*2); ctx.fill(); ctx.stroke();
        radialGlow(ctx, x + r*1.2, y + r*(HQ?7.5:6.9), r*4.0, "rgba(255,255,255,0.35)");
      }
    }

    // ----- Boot -----
    setValLabels();
  </script>
</body>
</html>
